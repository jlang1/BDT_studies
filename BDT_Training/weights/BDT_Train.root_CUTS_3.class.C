// Class: ReadCUTS_3
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::CUTS_3
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/09       [336393]
Creator        : jlang
Date           : Tue Dec  8 16:22:08 2015
Host           : Linux ekpams2 2.6.32-504.16.2.el6.x86_64 #1 SMP Tue Apr 21 21:44:51 CEST 2015 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /usr/users/jlang/BDT/Test/BDT_Training
Training events: 1332
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "True" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "10" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "3" [Number of steps during node cut optimisation]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Verbose" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "2" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "1332" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
v0                            v0                            v0                            v0                                                              'F'    [-0.490635514259,1.48405468464]
v1                            v1                            v1                            v1                                                              'F'    [-7.37883806229,7.25839614868]
v2                            v2                            v2                            v2                                                              'F'    [-1.8986569643,6.2026591301]
v3                            v3                            v3                            v3                                                              'F'    [1.46819293499,2.39548110962]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new CUTS_3Node
   
#ifndef CUTS_3Node__def
#define CUTS_3Node__def
   
class CUTS_3Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   CUTS_3Node ( CUTS_3Node* left,CUTS_3Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~CUTS_3Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   CUTS_3Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   CUTS_3Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   CUTS_3Node*   fLeft;     // pointer to the left daughter node
   CUTS_3Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   CUTS_3Node::~CUTS_3Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool CUTS_3Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool CUTS_3Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadCUTS_3 : public IClassifierReader {

 public:

   // constructor
   ReadCUTS_3( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadCUTS_3" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "v0", "v1", "v2", "v3" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = -0.490635514259338;
      fVmax[0] = 1.48405468463898;
      fVmin[1] = -7.37883806228638;
      fVmax[1] = 7.25839614868164;
      fVmin[2] = -1.89865696430206;
      fVmax[2] = 6.20265913009644;
      fVmin[3] = 1.46819293498993;
      fVmax[3] = 2.39548110961914;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadCUTS_3() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<CUTS_3Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadCUTS_3::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      CUTS_3Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(CUTS_3Node*)current->GetRight();
         else current=(CUTS_3Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadCUTS_3::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(2.51122395810537);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.04777, 0, 1, 0.994118,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243056,-99) , 
0, 0.467186, 1, 0, 0.480892,-99) , 
NN(
0, 
0, 
-1, 1.72844, 0, -1, 0.015748,-99) , 
3, 1.81546, 0, 0, 0.193431,-99) , 
3, 1.93184, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.29793);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.04777, 0, 1, 0.932054,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.71232, 0, 0, 0.510279,-99) , 
NN(
0, 
0, 
-1, 1.699, 0, -1, 0.135339,-99) , 
2, 1.77287, 0, 0, 0.336326,-99) , 
3, 1.93184, 0, 0, 0.467841,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.58983);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.214695,-99) , 
3, 1.96072, 0, 0, 0.541754,-99) , 
3, 2.04777, 0, 0, 0.789305,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.721647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0774696,-99) , 
3, 1.8178, 0, 0, 0.4781,-99) , 
NN(
0, 
0, 
-1, 1.81546, 1, -1, 0.184753,-99) , 
0, 0.506282, 0, 0, 0.29941,-99) , 
3, 1.93184, 0, 0, 0.380703,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.486677);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.844495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397064,-99) , 
2, 1.80816, 0, 0, 0.692237,-99) , 
3, 2.04777, 0, 0, 0.827978,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.69971, 0, 0, 0.493814,-99) , 
NN(
0, 
0, 
-1, -0.0781105, 1, -1, 0.119235,-99) , 
0, 0.995168, 1, 0, 0.448127,-99) , 
3, 1.93184, 0, 0, 0.494602,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.743046);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.04777, 0, 1, 0.808022,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.958691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486704,-99) , 
2, 4.53334, 0, 0, 0.647926,-99) , 
NN(
0, 
0, 
-1, 1.69971, 0, -1, 0.338252,-99) , 
2, 3.60863, 0, 0, 0.362805,-99) , 
3, 1.93184, 0, 0, 0.410445,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.434711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.549945,-99) , 
3, 2.04801, 0, 0, 0.564871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.547487,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.304324);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.447705,-99) , 
3, 2.04801, 0, 0, 0.462709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.450979,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.263899);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.523576,-99) , 
3, 2.04801, 0, 0, 0.534783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.523005,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.232997);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0.379405, 0, -1, 0.460337,-99) , 
3, 2.04801, 0, 0, 0.47153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.46235,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.228691);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.34862, 0, 1, 0.538957,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.128727,-99) , 
3, 2.04593, 0, 0, 0.15508,-99) , 
2, 0.476791, 0, 0, 0.527425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.518223,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.201707);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.464623,-99) , 
3, 2.04801, 0, 0, 0.473521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.466104,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.182299);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.514986,-99) , 
3, 2.04801, 0, 0, 0.5223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.514867,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.387298);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.213596, 1, 1, 0.534303,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295787,-99) , 
3, 1.93799, 0, 0, 0.320643,-99) , 
0, 0.617949, 1, 0, 0.489105,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.178178,-99) , 
0, 1.11412, 1, 0, 0.484209,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.0266152,-99) , 
1, -0.0781105, 1, 0, 0.287462,-99) , 
0, 0.990382, 1, 0, 0.471966,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.708551);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.844993,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409215,-99) , 
0, 0.55905, 1, 0, 0.598269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610608,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296302,-99) , 
3, 1.90518, 0, 0, 0.345225,-99) , 
0, 0.744131, 1, 0, 0.482056,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.806174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393052,-99) , 
2, 2.61895, 1, 0, 0.662046,-99) , 
NN(
0, 
0, 
-1, 0.314546, 1, -1, 0.353994,-99) , 
0, -0.243812, 1, 0, 0.379857,-99) , 
0, 0.49671, 0, 0, 0.419912,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.277421);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.319669, 1, 1, 0.87285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486466,-99) , 
1, -0.060221, 1, 0, 0.537176,-99) , 
2, 4.29404, 0, 0, 0.549068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.542836,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.297664);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556875,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.549764,-99) , 
3, 2.04801, 0, 0, 0.557015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.551459,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.508698);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.72884, 0, 0, 0.731572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358445,-99) , 
0, 0.460818, 0, 0, 0.436651,-99) , 
3, 1.81576, 1, 0, 0.476169,-99) , 
3, 2.16366, 0, 0, 0.480472,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.407781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0096131, 0, 1, 0.805074,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489579,-99) , 
0, 0.00301108, 1, 0, 0.524754,-99) , 
2, 4.06408, 0, 0, 0.541508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394504,-99) , 
2, 1.87377, 1, 0, 0.466548,-99) , 
NN(
0, 
0, 
-1, 1.1144, 1, -1, 0.275397,-99) , 
0, 0.744131, 1, 0, 0.370588,-99) , 
0, 0.49671, 1, 0, 0.473042,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.311311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.93184, 0, 1, 0.584427,-99) , 
NN(
0, 
0, 
-1, 1.23741, 1, -1, 0.434118,-99) , 
0, 0.49671, 1, 0, 0.525893,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0753951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498357,-99) , 
3, 1.96059, 0, 0, 0.505673,-99) , 
3, 2.04801, 0, 0, 0.512433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.509035,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.133213);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.04801, 0, 1, 0.530252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.526862,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.322581);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.52829, 0, 0, 0.674692,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457538,-99) , 
3, 1.98977, 0, 0, 0.466384,-99) , 
3, 1.81576, 1, 0, 0.490861,-99) , 
3, 2.16366, 0, 0, 0.494007,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.296912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.34862, 0, 1, 0.567036,-99) , 
NN(
0, 
0, 
-1, -0.119339, 0, -1, 0.301499,-99) , 
2, 0.476791, 0, 0, 0.558832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.555457,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.089961);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.484619,-99) , 
3, 2.04801, 0, 0, 0.489477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.486901,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.112535);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.507104,-99) , 
3, 2.04801, 0, 0, 0.511549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.508973,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.13129);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.72871, 0, -1, 0.474177,-99) , 
3, 1.98954, 0, 0, 0.479657,-99) , 
3, 2.16366, 0, 0, 0.481887,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.123193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.512163,-99) , 
3, 2.04801, 0, 0, 0.51607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.51376,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.298686);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.264661, 1, 1, 0.780713,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458504,-99) , 
2, 2.87756, 0, 0, 0.486571,-99) , 
2, 4.30378, 0, 0, 0.493612,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00214449,-99) , 
0, 1.23731, 1, 0, 0.530979,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.0332561,-99) , 
1, -0.0781105, 1, 0, 0.366587,-99) , 
0, 0.990382, 1, 0, 0.483986,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.385883);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0290146,-99) , 
2, -0.444289, 0, 0, 0.56726,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414178,-99) , 
2, 3.35478, 0, 0, 0.486882,-99) , 
2, 2.40491, 1, 0, 0.533044,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0028888,-99) , 
0, 1.23731, 1, 0, 0.480069,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.044319,-99) , 
1, -0.0781105, 1, 0, 0.344639,-99) , 
0, 0.990382, 1, 0, 0.519677,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.142235);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485594,-99) , 
3, 1.98954, 0, 0, 0.490431,-99) , 
3, 2.16366, 0, 0, 0.492524,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.168793,-99) , 
1, -0.745301, 0, 0, 0.408656,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.0638567,-99) , 
1, -0.0781105, 1, 0, 0.311608,-99) , 
0, 0.990382, 1, 0, 0.480371,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.165815);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.04801, 0, 1, 0.529141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.527147,-99) , 
NN(
0, 
0, 
-1, 1.23749, 1, -1, 0.308987,-99) , 
0, 0.990382, 1, 0, 0.512915,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.135211);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48001,-99) , 
3, 1.98954, 0, 0, 0.484208,-99) , 
3, 2.16366, 0, 0, 0.486028,-99) , 
NN(
0, 
0, 
-1, 1.23749, 1, -1, 0.345463,-99) , 
0, 0.990382, 1, 0, 0.477087,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.120879);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.04801, 0, 1, 0.520757,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.519064,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.032555,-99) , 
0, 1.17423, 1, 0, 0.459153,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0187564,-99) , 
0, 1.23749, 1, 0, 0.376641,-99) , 
0, 0.990382, 1, 0, 0.510153,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.190224);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470968,-99) , 
3, 1.81576, 1, 0, 0.487453,-99) , 
3, 2.16366, 0, 0, 0.489048,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.129635,-99) , 
1, -0.0781105, 1, 0, 0.435655,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0211155,-99) , 
0, 1.23749, 1, 0, 0.361168,-99) , 
0, 0.990382, 1, 0, 0.481161,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.148792);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.04801, 0, 1, 0.52772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.525937,-99) , 
NN(
0, 
0, 
-1, 1.23749, 1, -1, 0.341411,-99) , 
0, 0.990382, 1, 0, 0.514784,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0944588);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.480871,-99) , 
3, 2.04801, 0, 0, 0.483932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.482281,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0889963);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51137,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.504476,-99) , 
3, 2.04801, 0, 0, 0.507266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.505613,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.257816);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406483,-99) , 
0, 0.835825, 1, 0, 0.504082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0225178,-99) , 
0, 1.20767, 1, 0, 0.240088,-99) , 
0, 1.11385, 1, 0, 0.496366,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.734812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436512,-99) , 
2, 2.49689, 0, 0, 0.519373,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0755937,-99) , 
2, 1.43582, 1, 0, 0.231546,-99) , 
1, 1.27313, 1, 0, 0.419829,-99) , 
0, 0.00303704, 0, 0, 0.484086,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.237896);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.126672, 0, 0, 0.495749,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0347954,-99) , 
0, 1.23741, 1, 0, 0.48589,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450835,-99) , 
1, 1.40424, 0, 0, 0.540142,-99) , 
NN(
0, 
0, 
-1, 0.314546, 1, -1, 0.420666,-99) , 
0, -0.243812, 1, 0, 0.430206,-99) , 
0, 0.49671, 0, 0, 0.452121,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.347292);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49181,-99) , 
3, 1.93532, 0, 0, 0.516669,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357081,-99) , 
0, 0.311881, 1, 0, 0.455986,-99) , 
0, 0.249834, 1, 0, 0.487622,-99) , 
NN(
0, 
0, 
-1, 1.23741, 1, -1, 0.430873,-99) , 
0, 0.49671, 1, 0, 0.465093,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.205699);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.535592,-99) , 
3, 2.04801, 0, 0, 0.538184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.536608,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0733314);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.485416,-99) , 
3, 2.04801, 0, 0, 0.488021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.486725,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0707366);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.503744,-99) , 
3, 2.04801, 0, 0, 0.506168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.504871,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.104);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481772,-99) , 
3, 1.96059, 0, 0, 0.486419,-99) , 
3, 2.04801, 0, 0, 0.488841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.487631,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0988554);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.511958,-99) , 
3, 2.04801, 0, 0, 0.514145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.512936,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0618844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.487706,-99) , 
3, 2.04801, 0, 0, 0.489894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.488796,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0600264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.503174,-99) , 
3, 2.04801, 0, 0, 0.505233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.504134,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.090644);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484233,-99) , 
3, 1.96059, 0, 0, 0.488426,-99) , 
3, 2.04801, 0, 0, 0.490484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.489448,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0867115);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.510723,-99) , 
3, 2.04801, 0, 0, 0.512605,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.51157,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0831062);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48556,-99) , 
3, 1.96059, 0, 0, 0.489393,-99) , 
3, 2.04801, 0, 0, 0.491276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.490325,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0797889);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.509863,-99) , 
3, 2.04801, 0, 0, 0.511598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.510647,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0767264);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486681,-99) , 
3, 1.96059, 0, 0, 0.490211,-99) , 
3, 2.04801, 0, 0, 0.491946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.491067,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0738904);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.509131,-99) , 
3, 2.04801, 0, 0, 0.51074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.509861,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0712566);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48764,-99) , 
3, 1.96059, 0, 0, 0.490911,-99) , 
3, 2.04801, 0, 0, 0.492521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.491703,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0688043);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.5085,-99) , 
3, 2.04801, 0, 0, 0.51,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.509183,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.176066);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.93532, 0, 1, 0.549827,-99) , 
NN(
0, 
0, 
-1, 0.506035, 0, -1, 0.470323,-99) , 
0, 0.248421, 1, 0, 0.497118,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555959,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00924101,-99) , 
2, 1.7124, 0, 0, 0.495852,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.111627,-99) , 
1, -0.0781105, 1, 0, 0.41292,-99) , 
0, 0.990382, 1, 0, 0.492255,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.262851);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379972,-99) , 
3, 1.93184, 1, 0, 0.530466,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612609,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445918,-99) , 
1, -1.89195, 1, 0, 0.481076,-99) , 
1, -0.060221, 0, 0, 0.511502,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237237,-99) , 
1, -0.745301, 0, 0, 0.46089,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.130317,-99) , 
1, -0.0781105, 1, 0, 0.392418,-99) , 
0, 0.990382, 1, 0, 0.504771,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.166097);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.995514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469923,-99) , 
0, 0.264661, 1, 0, 0.674612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521642,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469662,-99) , 
1, -0.060221, 1, 0, 0.489382,-99) , 
2, 4.30378, 0, 0, 0.492915,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.159686,-99) , 
0, 1.08275, 0, 0, 0.491117,-99) , 
NN(
0, 
0, 
-1, 1.20767, 1, -1, 0.220383,-99) , 
0, 1.11421, 1, 0, 0.385281,-99) , 
0, 0.990382, 1, 0, 0.48704,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0451679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.264661, 1, 1, 0.690442,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498612,-99) , 
3, 2.16366, 0, 0, 0.499374,-99) , 
2, 4.30378, 0, 0, 0.502908,-99) , 
NN(
0, 
0, 
-1, 1.23749, 1, -1, 0.387277,-99) , 
0, 0.990382, 1, 0, 0.496795,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0794295);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.264661, 1, 1, 0.680706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.510631,-99) , 
2, 4.30378, 0, 0, 0.51375,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0355438,-99) , 
0, 1.17423, 1, 0, 0.443321,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.048326,-99) , 
0, 1.23749, 1, 0, 0.398048,-99) , 
0, 0.990382, 1, 0, 0.507661,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0762136);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.994009,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480272,-99) , 
0, 0.264661, 1, 0, 0.6632,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490103,-99) , 
3, 2.16366, 0, 0, 0.49083,-99) , 
2, 4.30378, 0, 0, 0.493951,-99) , 
NN(
0, 
0, 
-1, 1.23749, 1, -1, 0.386216,-99) , 
0, 0.990382, 1, 0, 0.488319,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0733052);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.993538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499315,-99) , 
0, 0.264661, 1, 0, 0.671141,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.509828,-99) , 
2, 4.30378, 0, 0, 0.512709,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501054,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0412826,-99) , 
0, 1.17423, 1, 0, 0.446868,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0560087,-99) , 
0, 1.23749, 1, 0, 0.404431,-99) , 
0, 0.990382, 1, 0, 0.507091,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0866858);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.7991, 0, 1, 0.678978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490876,-99) , 
3, 2.16366, 0, 0, 0.491551,-99) , 
2, 4.30378, 0, 0, 0.49486,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261906,-99) , 
2, 2.41835, 1, 0, 0.434827,-99) , 
NN(
0, 
0, 
-1, 0.168941, 0, -1, 0.0544438,-99) , 
2, 1.5381, 0, 0, 0.393179,-99) , 
0, 0.990382, 1, 0, 0.489614,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.144048);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.77242, 0, 1, 0.530856,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269004,-99) , 
2, 0.818759, 0, 0, 0.491247,-99) , 
1, -0.060221, 0, 0, 0.515714,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279006,-99) , 
2, 2.41835, 1, 0, 0.432132,-99) , 
NN(
0, 
0, 
-1, 0.168941, 0, -1, 0.0590826,-99) , 
2, 1.5381, 0, 0, 0.392224,-99) , 
0, 0.990382, 1, 0, 0.509433,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.125865);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46331,-99) , 
2, 4.7991, 0, 0, 0.626761,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478613,-99) , 
3, 2.16366, 0, 0, 0.479232,-99) , 
2, 4.30378, 0, 0, 0.481751,-99) , 
NN(
NN(
0, 
0, 
-1, 1.11602, 1, 1, 0.761627,-99) , 
NN(
0, 
0, 
-1, -0.0781105, 1, -1, 0.349935,-99) , 
3, 1.90474, 0, 0, 0.390576,-99) , 
0, 0.990382, 1, 0, 0.477201,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.165962);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473894,-99) , 
3, 1.87428, 0, 0, 0.513443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.512815,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0480731,-99) , 
0, 1.17423, 1, 0, 0.453732,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0662098,-99) , 
0, 1.23749, 1, 0, 0.414056,-99) , 
0, 0.990382, 1, 0, 0.507968,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.107461);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.77242, 0, 1, 0.524372,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316476,-99) , 
2, 0.818759, 0, 0, 0.487667,-99) , 
1, -0.060221, 0, 0, 0.510359,-99) , 
NN(
NN(
0, 
0, 
-1, 1.11602, 1, 1, 0.735759,-99) , 
NN(
0, 
0, 
-1, -0.0781105, 1, -1, 0.352003,-99) , 
3, 1.90474, 0, 0, 0.388011,-99) , 
0, 0.990382, 1, 0, 0.50441,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.21741);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.668837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.52829, 0, 0, 0.611373,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46403,-99) , 
3, 1.98977, 0, 0, 0.466656,-99) , 
3, 1.81576, 1, 0, 0.480635,-99) , 
3, 2.16366, 0, 0, 0.481254,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.132053);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.524964,-99) , 
3, 2.04801, 0, 0, 0.526219,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.525536,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.182748);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467671,-99) , 
2, 1.9112, 1, 0, 0.497471,-99) , 
NN(
0, 
0, 
-1, 0.591822, 1, -1, 0.0168945,-99) , 
2, -0.381107, 0, 0, 0.496437,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322136,-99) , 
0, 0.70217, 1, 0, 0.618507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.180272,-99) , 
0, 0.0330164, 0, 0, 0.40278,-99) , 
2, 4.17733, 1, 0, 0.49303,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.212871);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.94445, 0, 1, 0.540624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423757,-99) , 
1, -0.060221, 0, 0, 0.475684,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.185017,-99) , 
2, 1.36872, 1, 0, 0.294225,-99) , 
3, 1.92805, 1, 0, 0.461018,-99) , 
2, 2.152, 0, 0, 0.500099,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.198481);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496614,-99) , 
3, 1.94452, 0, 0, 0.511501,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429051,-99) , 
0, 0.49671, 0, 0, 0.459386,-99) , 
2, 2.65399, 0, 0, 0.475377,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315594,-99) , 
0, 0.70217, 1, 0, 0.581106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.175863,-99) , 
0, 0.0330164, 0, 0, 0.372701,-99) , 
2, 4.17733, 1, 0, 0.471731,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.139403);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.94445, 0, 1, 0.520857,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516534,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312949,-99) , 
3, 1.92805, 1, 0, 0.494968,-99) , 
NN(
0, 
0, 
-1, -2.11071, 0, -1, 0.427284,-99) , 
0, 0.49671, 1, 0, 0.470845,-99) , 
2, 2.152, 0, 0, 0.495348,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.177326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.94452, 0, 1, 0.523639,-99) , 
NN(
0, 
0, 
-1, 0.375846, 0, -1, 0.459847,-99) , 
2, 2.65399, 0, 0, 0.479453,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.328491,-99) , 
0, 0.70217, 1, 0, 0.564184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.18459,-99) , 
0, 0.0330164, 0, 0, 0.364224,-99) , 
2, 4.17733, 1, 0, 0.475505,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.192067);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463409,-99) , 
2, 1.9112, 1, 0, 0.497289,-99) , 
NN(
0, 
0, 
-1, 0.591822, 1, -1, 0.0270154,-99) , 
2, -0.381107, 0, 0, 0.496468,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.918005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316209,-99) , 
1, 0.0634033, 0, 0, 0.581444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.212784,-99) , 
0, 0.0330164, 0, 0, 0.387737,-99) , 
2, 4.17733, 1, 0, 0.492914,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.162326);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487449,-99) , 
1, -1.20784, 1, 0, 0.510703,-99) , 
3, 1.94445, 0, 0, 0.522196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516739,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437762,-99) , 
3, 1.87068, 0, 0, 0.480292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.69812, 0, 0, 0.479385,-99) , 
2, 2.152, 0, 0, 0.500411,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.248519);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3104,-99) , 
0, 0.994473, 1, 0, 0.537294,-99) , 
3, 1.94445, 0, 0, 0.547352,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684058,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468201,-99) , 
3, 1.81227, 1, 0, 0.484623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261837,-99) , 
2, 1.36872, 1, 0, 0.367589,-99) , 
3, 1.92805, 1, 0, 0.476199,-99) , 
2, 2.152, 0, 0, 0.511134,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0929517);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.04801, 0, 1, 0.514648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.513939,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.998754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368559,-99) , 
0, 0.70217, 1, 0, 0.575035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218219,-99) , 
0, 0.0330164, 0, 0, 0.385155,-99) , 
2, 4.17733, 1, 0, 0.509906,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0569351);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.487478,-99) , 
3, 2.04801, 0, 0, 0.488598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.487953,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0384104);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.501709,-99) , 
3, 2.04801, 0, 0, 0.502768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.502122,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.227494);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461479,-99) , 
0, 0.506282, 1, 0, 0.519169,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278448,-99) , 
0, 0.380917, 0, 0, 0.386528,-99) , 
3, 1.92805, 1, 0, 0.510063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459949,-99) , 
2, 4.73587, 0, 0, 0.464673,-99) , 
3, 1.94445, 0, 0, 0.474619,-99) , 
2, 2.152, 1, 0, 0.492662,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.245226);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0375755,-99) , 
0, 1.23741, 1, 0, 0.547528,-99) , 
NN(
0, 
0, 
-1, 1.18234, 0, -1, 0.0116387,-99) , 
2, 0.126672, 0, 0, 0.542234,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463458,-99) , 
2, 2.41819, 0, 0, 0.62599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461371,-99) , 
1, 2.0843, 0, 0, 0.484511,-99) , 
3, 1.93184, 0, 0, 0.492752,-99) , 
0, 0.49671, 0, 0, 0.512088,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.141254);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.94452, 0, 1, 0.581729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499724,-99) , 
0, -0.243868, 1, 0, 0.513397,-99) , 
2, 2.31504, 0, 0, 0.541567,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395485,-99) , 
2, 3.16765, 1, 0, 0.48742,-99) , 
NN(
0, 
0, 
-1, 1.18234, 0, -1, 0.0148253,-99) , 
2, 0.126672, 0, 0, 0.483247,-99) , 
0, 0.49671, 1, 0, 0.518771,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.171595);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.93184, 0, 1, 0.544367,-99) , 
NN(
0, 
0, 
-1, 0.126672, 0, -1, 0.459652,-99) , 
0, 0.49671, 1, 0, 0.511206,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0365711);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.501564,-99) , 
3, 2.04801, 0, 0, 0.502564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.501929,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0362087);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.492529,-99) , 
3, 2.04801, 0, 0, 0.493529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.492916,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0355647);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.501581,-99) , 
3, 2.04801, 0, 0, 0.502545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.501933,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0349433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.492791,-99) , 
3, 2.04801, 0, 0, 0.493755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.493164,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0343432);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.501526,-99) , 
3, 2.04801, 0, 0, 0.502458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.501866,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0337634);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.78723, 0, -1, 0.493035,-99) , 
3, 2.04801, 0, 0, 0.493966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.493395,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0332028);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.501475,-99) , 
3, 2.04801, 0, 0, 0.502376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.501804,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.053114);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490652,-99) , 
3, 1.96059, 0, 0, 0.493263,-99) , 
3, 2.04801, 0, 0, 0.494163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.49361,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0517396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.506406,-99) , 
3, 2.04801, 0, 0, 0.507261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.506708,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0504346);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491127,-99) , 
3, 1.96059, 0, 0, 0.493604,-99) , 
3, 2.04801, 0, 0, 0.494458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.493933,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0491938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.506091,-99) , 
3, 2.04801, 0, 0, 0.506903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.506378,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0480126);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491556,-99) , 
3, 1.96059, 0, 0, 0.493912,-99) , 
3, 2.04801, 0, 0, 0.494724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.494224,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0468868);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.505804,-99) , 
3, 2.04801, 0, 0, 0.506579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.506079,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0458126);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491946,-99) , 
3, 1.96059, 0, 0, 0.494191,-99) , 
3, 2.04801, 0, 0, 0.494966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.494488,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0447866);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78723, 0, 0, 0.505544,-99) , 
3, 2.04801, 0, 0, 0.506284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.505807,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0438055);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492301,-99) , 
3, 1.96059, 0, 0, 0.494446,-99) , 
3, 2.04801, 0, 0, 0.495187,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.70001, 0, 0, 0.49473,-99)    );
   return;
};
 
// Clean up
inline void ReadCUTS_3::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadCUTS_3::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
