// Class: ReadCUTS_25
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::CUTS_25
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/09       [336393]
Creator        : jlang
Date           : Tue Dec  8 16:22:07 2015
Host           : Linux ekpams2 2.6.32-504.16.2.el6.x86_64 #1 SMP Tue Apr 21 21:44:51 CEST 2015 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /usr/users/jlang/BDT/Test/BDT_Training
Training events: 1332
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "True" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "10" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "25" [Number of steps during node cut optimisation]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Verbose" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "2" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "1332" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
v0                            v0                            v0                            v0                                                              'F'    [-0.490635514259,1.48405468464]
v1                            v1                            v1                            v1                                                              'F'    [-7.37883806229,7.25839614868]
v2                            v2                            v2                            v2                                                              'F'    [-1.8986569643,6.2026591301]
v3                            v3                            v3                            v3                                                              'F'    [1.46819293499,2.39548110962]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new CUTS_25Node
   
#ifndef CUTS_25Node__def
#define CUTS_25Node__def
   
class CUTS_25Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   CUTS_25Node ( CUTS_25Node* left,CUTS_25Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~CUTS_25Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   CUTS_25Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   CUTS_25Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   CUTS_25Node*   fLeft;     // pointer to the left daughter node
   CUTS_25Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   CUTS_25Node::~CUTS_25Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool CUTS_25Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool CUTS_25Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadCUTS_25 : public IClassifierReader {

 public:

   // constructor
   ReadCUTS_25( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadCUTS_25" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "v0", "v1", "v2", "v3" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = -0.490635514259338;
      fVmax[0] = 1.48405468463898;
      fVmin[1] = -7.37883806228638;
      fVmax[1] = 7.25839614868164;
      fVmin[2] = -1.89865696430206;
      fVmax[2] = 6.20265913009644;
      fVmin[3] = 1.46819293498993;
      fVmax[3] = 2.39548110961914;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadCUTS_25() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<CUTS_25Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadCUTS_25::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      CUTS_25Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(CUTS_25Node*)current->GetRight();
         else current=(CUTS_25Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadCUTS_25::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(2.53304872579476);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.95313, 0, 1, 0.996016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.776316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375,-99) , 
0, 0.611694, 1, 0, 0.68,-99) , 
3, 1.9352, 0, 0, 0.943522,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.15534,-99) , 
0, 0.539392, 1, 0, 0.405286,-99) , 
NN(
0, 
0, 
-1, 1.80021, 0, -1, 0.0119284,-99) , 
3, 1.81376, 0, 0, 0.134247,-99) , 
3, 1.89617, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.50178);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284223,-99) , 
2, 3.02425, 0, 0, 0.575361,-99) , 
3, 1.9497, 0, 0, 0.933489,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79651, 0, 0, 0.479424,-99) , 
NN(
0, 
0, 
-1, 1.5218, 0, -1, 0.149016,-99) , 
2, 2.33772, 0, 0, 0.260607,-99) , 
3, 1.93184, 0, 0, 0.415457,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.47535);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.9497, 0, 1, 0.939102,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.719965,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.80596, 0, 0, 0.54257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.81357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.20834,-99) , 
0, 0.539824, 0, 0, 0.225861,-99) , 
0, 0.581495, 0, 0, 0.336454,-99) , 
3, 1.93184, 0, 0, 0.429057,-99)    );
  // itree = 3
  fBoostWeights.push_back(1.00718);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.798321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457947,-99) , 
2, 1.50093, 0, 0, 0.668113,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304626,-99) , 
3, 1.95381, 0, 0, 0.371039,-99) , 
2, 2.38541, 1, 0, 0.533731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.49447,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.532964);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.035023, 1, 1, 0.610622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.579961,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.85162);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.196368, 0, 1, 0.824016,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.843027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0988917,-99) , 
2, 1.62101, 1, 0, 0.458244,-99) , 
1, 1.06613, 1, 0, 0.724631,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.963437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354638,-99) , 
2, 4.62669, 0, 0, 0.371648,-99) , 
3, 1.9675, 0, 0, 0.400629,-99) , 
0, -0.0349378, 1, 0, 0.460159,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.620078);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.90584, 0, 1, 0.62863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.611769,-99) , 
NN(
0, 
0, 
-1, 1.13565, 1, -1, 0.122101,-99) , 
0, 1.10431, 1, 0, 0.587941,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.505833);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5492,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369812,-99) , 
1, -0.382804, 1, 0, 0.42733,-99) , 
1, 2.75463, 0, 0, 0.439689,-99) , 
3, 1.9675, 0, 0, 0.456023,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.346871);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.733702, 1, 1, 0.908505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0672882,-99) , 
1, 1.65296, 0, 0, 0.29254,-99) , 
1, 1.10357, 1, 0, 0.805451,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.1832, 1, -1, 0.452277,-99) , 
3, 1.9675, 0, 0, 0.464605,-99) , 
2, 3.70995, 0, 0, 0.491268,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.408025);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.64724, 0, 1, 0.585406,-99) , 
NN(
0, 
0, 
-1, 1.89442, 0, -1, 0.0289686,-99) , 
0, 1.17994, 1, 0, 0.575093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.563715,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.256235);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.946399,-99) , 
NN(
0, 
0, 
-1, 0.474196, 0, -1, 0.451179,-99) , 
1, 2.75463, 0, 0, 0.460341,-99) , 
3, 1.9675, 0, 0, 0.469502,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.294757);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.742074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.194118,-99) , 
0, 0.79414, 1, 0, 0.706066,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.754361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493601,-99) , 
2, 3.72324, 0, 0, 0.514892,-99) , 
2, 1.2418, 1, 0, 0.542591,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.8175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0552658,-99) , 
1, 1.67419, 0, 0, 0.164183,-99) , 
2, 0.594056, 0, 0, 0.529207,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.485965);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599797,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75833, 0, 0, 0.594257,-99) , 
NN(
0, 
0, 
-1, 1.8731, 0, -1, 0.0370059,-99) , 
0, 1.18026, 1, 0, 0.58722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0552658,-99) , 
1, 1.67419, 0, 0, 0.162728,-99) , 
2, 0.594056, 0, 0, 0.574006,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.583105);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.90933,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0968076,-99) , 
0, 0.358903, 1, 0, 0.66704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37536,-99) , 
3, 1.90243, 0, 0, 0.430056,-99) , 
3, 1.81375, 1, 0, 0.456594,-99) , 
3, 1.9675, 0, 0, 0.463768,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.484486);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.611598, 1, 1, 0.820544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0386653,-99) , 
2, 2.54632, 0, 0, 0.473653,-99) , 
2, 1.95369, 1, 0, 0.661661,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.746772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.808964, 1, 0, 0.653525,-99) , 
NN(
0, 
0, 
-1, 1.33126, 1, -1, 0.44249,-99) , 
3, 1.82484, 1, 0, 0.481937,-99) , 
1, 1.62869, 0, 0, 0.503914,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.41859);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401531,-99) , 
3, 1.92039, 1, 0, 0.566969,-99) , 
3, 1.95248, 0, 0, 0.57384,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.566475,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.125079);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.994694,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489371,-99) , 
3, 1.97072, 0, 0, 0.494333,-99) , 
0, -0.414686, 1, 0, 0.499873,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579429,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.142006,-99) , 
2, 0.594056, 0, 0, 0.490542,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.158124);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.414686, 1, 1, 0.529888,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548683,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.140596,-99) , 
2, 0.594056, 0, 0, 0.520238,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.145143);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.99297,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481117,-99) , 
3, 1.97072, 0, 0, 0.485497,-99) , 
0, -0.414686, 1, 0, 0.490394,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509305,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.138592,-99) , 
2, 0.594056, 0, 0, 0.482194,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.164551);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.95468, 0, 1, 0.529397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75833, 0, 0, 0.525412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.473047,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.136513,-99) , 
2, 0.594056, 0, 0, 0.516831,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.152018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.99188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476868,-99) , 
3, 1.97072, 0, 0, 0.480659,-99) , 
0, -0.414686, 1, 0, 0.484903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514155,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.151635,-99) , 
2, 0.594056, 0, 0, 0.477986,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.153371);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498857,-99) , 
0, 0.660429, 0, 0, 0.525872,-99) , 
NN(
0, 
0, 
-1, 1.8731, 0, -1, 0.042216,-99) , 
0, 1.18026, 1, 0, 0.52176,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.476172,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.148967,-99) , 
2, 0.594056, 0, 0, 0.51444,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.247945);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549933,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75833, 0, 0, 0.546769,-99) , 
NN(
0, 
0, 
-1, 1.8731, 0, -1, 0.0488717,-99) , 
0, 1.18026, 1, 0, 0.542814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514493,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0466986,-99) , 
1, 1.67419, 0, 0, 0.164667,-99) , 
2, 0.594056, 0, 0, 0.535786,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.148302);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.991915,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0.474196, 0, -1, 0.469592,-99) , 
3, 1.9675, 0, 0, 0.473264,-99) , 
0, -0.414686, 1, 0, 0.477053,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0810618);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.73449, 0, 1, 0.516789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.513083,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0777698);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.990607,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492433,-99) , 
3, 1.97072, 0, 0, 0.495353,-99) , 
0, -0.414686, 1, 0, 0.49864,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.472023,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0435162,-99) , 
1, 1.67419, 0, 0, 0.165246,-99) , 
2, 0.594056, 0, 0, 0.493108,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.219686);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.64856, 0, 1, 0.5356,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.161704,-99) , 
3, 1.84146, 0, 0, 0.428056,-99) , 
0, 0.800508, 1, 0, 0.517611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -1, 0.491437,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0435162,-99) , 
1, 1.67419, 0, 0, 0.174202,-99) , 
2, 0.594056, 0, 0, 0.512067,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.167369);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.1832, 1, -1, 0.46079,-99) , 
3, 1.9675, 0, 0, 0.463755,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0695121);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496953,-99) , 
1, 2.64724, 0, 0, 0.502845,-99) , 
2, 4.73449, 0, 0, 0.508329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.505076,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.11114);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 4.73449, 0, 1, 0.524818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.521573,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.189709);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.990013,-99) , 
NN(
NN(
0, 
0, 
-1, 0.478811, 1, 1, 0.744374,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440285,-99) , 
2, 2.41436, 1, 0, 0.485348,-99) , 
2, 4.33312, 0, 0, 0.491118,-99) , 
0, -0.414686, 1, 0, 0.494142,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.419039);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469629,-99) , 
1, -0.16869, 0, 0, 0.558182,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189015,-99) , 
2, 3.04043, 1, 0, 0.393316,-99) , 
1, 1.24299, 1, 0, 0.523843,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.131286,-99) , 
3, 1.92805, 1, 0, 0.467519,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.203455,-99) , 
0, 0.929648, 0, 0, 0.267126,-99) , 
1, -0.623191, 0, 0, 0.424531,-99) , 
2, 1.84041, 0, 0, 0.488838,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.572812);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.311965,-99) , 
0, -0.187234, 0, 0, 0.580881,-99) , 
NN(
0, 
0, 
-1, 0.492921, 1, -1, 0.393701,-99) , 
1, 0.786386, 1, 0, 0.525083,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.015265,-99) , 
2, 1.71954, 1, 0, 0.490879,-99) , 
NN(
0, 
0, 
-1, 0.976824, 1, -1, 0.317503,-99) , 
3, 1.89268, 0, 0, 0.372494,-99) , 
2, 1.84041, 0, 0, 0.471208,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.425581);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.96703,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452382,-99) , 
0, 0.780585, 1, 0, 0.932085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.820394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450796,-99) , 
2, 3.5959, 0, 0, 0.471386,-99) , 
0, 0.74762, 0, 0, 0.488244,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.738638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370609,-99) , 
3, 1.90474, 0, 0, 0.47061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.106381,-99) , 
3, 1.93411, 0, 0, 0.13613,-99) , 
0, 0.906074, 0, 0, 0.375165,-99) , 
0, 0.800508, 1, 0, 0.467897,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.405246);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.74762, 0, 1, 0.577185,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363745,-99) , 
1, -0.489748, 1, 0, 0.519785,-99) , 
NN(
0, 
0, 
-1, 0.849281, 1, -1, 0.18082,-99) , 
0, 0.906074, 0, 0, 0.430687,-99) , 
0, 0.800508, 1, 0, 0.552237,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.249957);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.990101,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.916745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485311,-99) , 
0, 0.0385422, 0, 0, 0.556193,-99) , 
NN(
0, 
0, 
-1, 0.204724, 0, -1, 0.446808,-99) , 
0, 0.0979073, 1, 0, 0.470674,-99) , 
0, -0.414686, 1, 0, 0.474245,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.169491);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.414686, 1, 1, 0.53696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576946,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0393157,-99) , 
1, 1.67419, 0, 0, 0.192791,-99) , 
2, 0.594056, 0, 0, 0.531619,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.262185);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271116,-99) , 
2, 1.78457, 0, 0, 0.661893,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350739,-99) , 
3, 1.90762, 1, 0, 0.478554,-99) , 
3, 1.92916, 0, 0, 0.493245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.490178,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.37175);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462941,-99) , 
3, 1.94289, 0, 0, 0.473382,-99) , 
0, -0.268383, 1, 0, 0.488235,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.979589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470859,-99) , 
1, -0.864597, 1, 0, 0.550194,-99) , 
NN(
0, 
0, 
-1, -0.938232, 0, -1, 0.347419,-99) , 
0, 0.0588627, 1, 0, 0.404223,-99) , 
3, 1.86051, 0, 0, 0.45304,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.517437);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.819579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.231302,-99) , 
2, 1.4354, 0, 0, 0.731888,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443155,-99) , 
1, 0.331851, 0, 0, 0.543182,-99) , 
1, -0.939211, 1, 0, 0.573042,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.858615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47884,-99) , 
1, -0.566601, 1, 0, 0.526677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.968782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.166994,-99) , 
0, 0.0501521, 1, 0, 0.313913,-99) , 
1, -0.938232, 0, 0, 0.487441,-99) , 
3, 1.86051, 0, 0, 0.537806,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.322363);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.73449, 0, 1, 0.576013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.57368,-99) , 
NN(
0, 
0, 
-1, 1.8731, 0, -1, 0.045462,-99) , 
0, 1.18026, 1, 0, 0.570638,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.111564);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.989559,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.823277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486119,-99) , 
3, 1.79373, 1, 0, 0.493901,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0378241,-99) , 
1, 1.67419, 0, 0, 0.227712,-99) , 
2, 0.594056, 0, 0, 0.490011,-99) , 
0, -0.414686, 1, 0, 0.4921,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.122148);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.942854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78136, 0, 0, 0.804757,-99) , 
NN(
0, 
0, 
-1, 1.95595, 0, 1, 0.515972,-99) , 
3, 1.79373, 1, 0, 0.522401,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605095,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0433743,-99) , 
1, 1.67419, 0, 0, 0.227592,-99) , 
2, 0.594056, 0, 0, 0.518265,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.320477);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.81616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.128137,-99) , 
0, 0.358903, 1, 0, 0.630557,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448142,-99) , 
0, 0.683803, 0, 0, 0.47332,-99) , 
3, 1.81375, 1, 0, 0.486443,-99) , 
3, 1.9675, 0, 0, 0.488469,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.324534);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.979428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471081,-99) , 
1, -0.267031, 0, 0, 0.897227,-99) , 
NN(
0, 
0, 
-1, 2.64724, 0, 1, 0.544231,-99) , 
0, 0.74762, 0, 0, 0.554418,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.945725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315554,-99) , 
2, 2.6015, 0, 0, 0.603407,-99) , 
NN(
0, 
0, 
-1, 2.84635, 1, -1, 0.306614,-99) , 
3, 1.90474, 0, 0, 0.378675,-99) , 
0, 0.800508, 1, 0, 0.527085,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.161839);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.98382,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465854,-99) , 
2, 4.73449, 0, 0, 0.468764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.466751,-99) , 
0, -0.414686, 1, 0, 0.468724,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0821247);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476693,-99) , 
0, 0.351049, 1, 0, 0.832185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0201489,-99) , 
2, 0.329974, 0, 0, 0.506465,-99) , 
1, 2.64724, 0, 0, 0.510461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.508406,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0777173);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.834352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488392,-99) , 
1, 2.64724, 0, 0, 0.492542,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.490693,-99) , 
NN(
0, 
0, 
-1, 1.2159, 1, -1, 0.0567465,-99) , 
0, 1.18026, 1, 0, 0.488531,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0613192);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.73449, 0, 1, 0.511509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.509661,-99) , 
NN(
0, 
0, 
-1, 1.2159, 1, -1, 0.0610526,-99) , 
0, 1.18026, 1, 0, 0.5075,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.096566);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.916717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78136, 0, 0, 0.758165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489211,-99) , 
3, 1.95595, 0, 0, 0.491158,-99) , 
3, 1.79373, 1, 0, 0.495815,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570706,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0407269,-99) , 
1, 1.67419, 0, 0, 0.230915,-99) , 
2, 0.594056, 0, 0, 0.492426,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.103408);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.909042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78136, 0, 0, 0.752907,-99) , 
NN(
0, 
0, 
-1, 1.03085, 1, 1, 0.515116,-99) , 
3, 1.79373, 1, 0, 0.519098,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0407269,-99) , 
1, 1.67419, 0, 0, 0.227364,-99) , 
2, 0.594056, 0, 0, 0.515482,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.1063);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.983961,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445542,-99) , 
2, 1.74436, 0, 0, 0.490497,-99) , 
0, -0.426687, 1, 0, 0.492187,-99) , 
NN(
0, 
0, 
-1, 1.2159, 1, -1, 0.0588772,-99) , 
0, 1.18026, 1, 0, 0.490161,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.344027);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.838954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259292,-99) , 
2, 0.684112, 0, 0, 0.678611,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.139601,-99) , 
0, 0.698418, 0, 0, 0.458586,-99) , 
0, 0.349181, 1, 0, 0.574418,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.941154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.79483, 1, 0, 0.823465,-99) , 
NN(
0, 
0, 
-1, 1.79615, 0, -1, 0.457106,-99) , 
3, 1.79373, 1, 0, 0.463603,-99) , 
2, 1.21723, 1, 0, 0.479532,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.230096);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.351049, 1, 1, 0.861792,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0297561,-99) , 
2, 0.329974, 0, 0, 0.545854,-99) , 
1, 2.64724, 0, 0, 0.549811,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.547993,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.157265);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.800437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260866,-99) , 
2, 1.88298, 0, 0, 0.605964,-99) , 
NN(
0, 
0, 
-1, 1.80488, 0, -1, 0.481062,-99) , 
3, 1.92893, 0, 0, 0.490149,-99) , 
3, 1.9675, 0, 0, 0.491719,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.198994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.86809, 0, 1, 0.650871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0805735,-99) , 
0, -0.177795, 0, 0, 0.522367,-99) , 
0, -0.234843, 1, 0, 0.529126,-99) , 
NN(
0, 
0, 
-1, 1.2159, 1, -1, 0.0697578,-99) , 
0, 1.18026, 1, 0, 0.52724,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.192285);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.458815, 0, 1, 0.985714,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.905588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47412,-99) , 
0, 0.0385422, 0, 0, 0.538823,-99) , 
NN(
0, 
0, 
-1, 0.204724, 0, -1, 0.462865,-99) , 
0, 0.0979073, 1, 0, 0.478473,-99) , 
0, -0.414686, 1, 0, 0.48009,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.134295);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.478811, 1, 1, 0.773601,-99) , 
NN(
NN(
0, 
0, 
-1, 3.62111, 0, 1, 0.526777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302742,-99) , 
2, 4.09164, 1, 0, 0.521872,-99) , 
2, 4.33312, 0, 0, 0.524994,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.19701);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.478811, 1, 1, 0.749221,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484438,-99) , 
1, -0.344362, 0, 0, 0.521323,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352991,-99) , 
0, 0.581495, 1, 0, 0.466832,-99) , 
1, -0.060221, 1, 0, 0.489775,-99) , 
2, 4.33312, 0, 0, 0.492888,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.447532);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.03467, 0, 1, 0.618991,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619829,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285905,-99) , 
2, 2.78232, 0, 0, 0.46885,-99) , 
2, 2.33611, 1, 0, 0.549673,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647077,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430454,-99) , 
0, 0.743117, 0, 0, 0.458872,-99) , 
NN(
0, 
0, 
-1, 1.15589, 0, -1, 0.0801894,-99) , 
0, 1.03277, 1, 0, 0.448555,-99) , 
1, -0.060221, 1, 0, 0.491103,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.219503);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.64724, 0, 1, 0.526504,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0249445,-99) , 
2, 2.85994, 1, 0, 0.599276,-99) , 
NN(
0, 
0, 
-1, 1.87293, 0, -1, 0.310362,-99) , 
0, 0.958617, 0, 0, 0.436168,-99) , 
0, 0.800508, 1, 0, 0.512195,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.235635);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.899341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492461,-99) , 
2, 4.35765, 0, 0, 0.498133,-99) , 
NN(
0, 
0, 
-1, -0.757592, 1, -1, 0.164172,-99) , 
3, 1.80567, 0, 0, 0.489227,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.823996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39238,-99) , 
0, -0.163815, 0, 0, 0.599653,-99) , 
NN(
0, 
0, 
-1, 0.216568, 0, -1, 0.384602,-99) , 
0, -0.0202116, 1, 0, 0.424877,-99) , 
2, 1.84041, 0, 0, 0.467913,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.292248);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.32429, 1, 1, 0.555305,-99) , 
NN(
0, 
0, 
-1, -0.757592, 1, -1, 0.199109,-99) , 
3, 1.80567, 0, 0, 0.546509,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.186805,-99) , 
3, 1.92805, 1, 0, 0.50849,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277842,-99) , 
3, 1.93515, 0, 0, 0.322478,-99) , 
1, -0.623191, 0, 0, 0.472094,-99) , 
2, 1.84041, 0, 0, 0.5223,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.2278);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471227,-99) , 
2, 3.06202, 0, 0, 0.610312,-99) , 
NN(
0, 
0, 
-1, 1.80488, 0, -1, 0.451351,-99) , 
3, 1.92893, 0, 0, 0.461614,-99) , 
3, 1.9675, 0, 0, 0.463232,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.10732);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.351049, 1, 1, 0.852515,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0349413,-99) , 
2, 0.329974, 0, 0, 0.514974,-99) , 
1, 2.64724, 0, 0, 0.51943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.517906,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.14926);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774487,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457075,-99) , 
1, 0.017842, 0, 0, 0.492733,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0417587,-99) , 
2, 0.594056, 0, 0, 0.488968,-99) , 
1, 2.75463, 0, 0, 0.491579,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.252048);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.944726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.204771,-99) , 
2, 1.54767, 0, 0, 0.837224,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.992857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283854,-99) , 
0, -0.0217585, 1, 0, 0.423834,-99) , 
1, -2.18614, 0, 0, 0.611636,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.85564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476453,-99) , 
1, 2.59739, 0, 0, 0.483045,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.162933,-99) , 
2, 2.8368, 0, 0, 0.291987,-99) , 
1, -1.40067, 0, 0, 0.477218,-99) , 
1, -1.74913, 1, 0, 0.487602,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.313811);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.797007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0272886,-99) , 
2, 1.57571, 0, 0, 0.713554,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92315, 0, 0, 0.0296808,-99) , 
2, 2.85994, 1, 0, 0.64123,-99) , 
NN(
NN(
0, 
0, 
-1, 0.196321, 0, 1, 0.584842,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522566,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32639,-99) , 
0, 0.850522, 1, 0, 0.501554,-99) , 
0, 0.286369, 1, 0, 0.536123,-99) , 
0, 0.952407, 0, 0, 0.543671,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.299213);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.98997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395818,-99) , 
1, -0.727964, 0, 0, 0.79683,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0937668,-99) , 
0, 0.994576, 1, 0, 0.376647,-99) , 
1, -0.474077, 1, 0, 0.605491,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.762734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460233,-99) , 
0, -0.225494, 1, 0, 0.472326,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.984917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0325068,-99) , 
0, -0.418448, 1, 0, 0.194223,-99) , 
0, -0.379635, 0, 0, 0.467473,-99) , 
0, 0.952407, 0, 0, 0.47657,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.374105);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.207736, 0, 1, 0.590551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394576,-99) , 
0, 0.461866, 0, 0, 0.518739,-99) , 
0, 0.327525, 1, 0, 0.547322,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413555,-99) , 
3, 1.86809, 0, 0, 0.559734,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00464602,-99) , 
0, -0.198705, 1, 0, 0.433927,-99) , 
0, -0.186837, 0, 0, 0.540077,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.403279);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.995791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00512777,-99) , 
2, 1.37031, 0, 0, 0.834499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403741,-99) , 
2, 1.77687, 0, 0, 0.487046,-99) , 
0, 0.52974, 0, 0, 0.502269,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.616432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431106,-99) , 
3, 1.86907, 0, 0, 0.538105,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0810633,-99) , 
1, 1.91732, 0, 0, 0.234775,-99) , 
1, 0.736791, 1, 0, 0.442216,-99) , 
0, 0.572659, 1, 0, 0.484352,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.47803);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.896353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0153038,-99) , 
0, 0.673163, 1, 0, 0.809952,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46319,-99) , 
0, -0.262787, 1, 0, 0.47941,-99) , 
2, 2.29408, 0, 0, 0.504719,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.250866,-99) , 
2, 2.89892, 1, 0, 0.553948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.990945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361878,-99) , 
2, 4.26741, 0, 0, 0.376217,-99) , 
0, 0.716027, 0, 0, 0.406251,-99) , 
2, 2.46359, 1, 0, 0.457623,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.301194);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.952406, 1, 1, 0.596611,-99) , 
NN(
NN(
0, 
0, 
-1, -1.83876, 1, 1, 0.523581,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.13868,-99) , 
1, 0.210902, 0, 0, 0.317886,-99) , 
2, 2.60789, 0, 0, 0.493919,-99) , 
2, 2.46359, 1, 0, 0.548593,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.379809);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.818254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29292,-99) , 
2, 0.684112, 0, 0, 0.69052,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.763198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281796,-99) , 
3, 1.91134, 0, 0, 0.482192,-99) , 
0, 0.349181, 1, 0, 0.596446,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.947125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76911, 0, 0, 0.840596,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444233,-99) , 
0, 1.02807, 0, 0, 0.452452,-99) , 
3, 1.79373, 1, 0, 0.459338,-99) , 
2, 1.21723, 1, 0, 0.478791,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.294465);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.931847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0103255,-99) , 
1, 0.265094, 1, 0, 0.908221,-99) , 
NN(
0, 
0, 
-1, 2.64724, 0, 1, 0.553889,-99) , 
0, 0.74762, 0, 0, 0.56258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.890428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00549486,-99) , 
0, 0.914021, 0, 0, 0.818602,-99) , 
NN(
0, 
0, 
-1, 1.83892, 0, -1, 0.402538,-99) , 
1, -1.70547, 1, 0, 0.453936,-99) , 
0, 0.800508, 1, 0, 0.547548,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.323219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.174056,-99) , 
1, -1.41776, 0, 0, 0.659424,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.701056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471808,-99) , 
3, 1.92476, 0, 0, 0.489103,-99) , 
0, 0.293126, 1, 0, 0.51408,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354936,-99) , 
1, 1.2775, 1, 0, 0.472588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.155569,-99) , 
0, 0.166606, 1, 0, 0.440375,-99) , 
0, 0.192911, 0, 0, 0.492303,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.405283);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.19821, 0, 1, 0.754855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345511,-99) , 
1, 2.06493, 1, 0, 0.561555,-99) , 
1, -1.74913, 1, 0, 0.575389,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.691799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396985,-99) , 
1, 2.10072, 0, 0, 0.41861,-99) , 
3, 1.93532, 0, 0, 0.427911,-99) , 
0, 0.268861, 0, 0, 0.522885,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.120916);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.813929,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483528,-99) , 
1, -1.53935, 1, 0, 0.493601,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0527507,-99) , 
2, 0.594056, 0, 0, 0.490671,-99) , 
1, 2.75463, 0, 0, 0.494185,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.150044);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.351049, 1, 1, 0.852955,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402135,-99) , 
2, 3.55995, 1, 0, 0.515708,-99) , 
1, 2.64724, 0, 0, 0.520633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.51902,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.227323);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.733702, 1, 1, 0.840156,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0158859,-99) , 
1, 1.65296, 0, 0, 0.113256,-99) , 
1, 1.10357, 1, 0, 0.665542,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688632,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479973,-99) , 
2, 3.28134, 0, 0, 0.4863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.978477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.137314,-99) , 
2, 3.56319, 1, 0, 0.328673,-99) , 
2, 3.49268, 1, 0, 0.479197,-99) , 
2, 3.70995, 0, 0, 0.487604,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.357895);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.996052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00461967,-99) , 
2, 1.37031, 0, 0, 0.836409,-99) , 
NN(
0, 
0, 
-1, 2.64724, 0, 1, 0.541669,-99) , 
0, 0.52974, 0, 0, 0.555861,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.81854, 0, 0, 0.568948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.219424,-99) , 
3, 1.90389, 0, 0, 0.342763,-99) , 
2, 2.77518, 1, 0, 0.487323,-99) , 
0, 0.572659, 1, 0, 0.53642,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.298969);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.98571,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481325,-99) , 
0, 0.733702, 1, 0, 0.820072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0143588,-99) , 
1, 1.65296, 0, 0, 0.0865827,-99) , 
1, 1.10357, 1, 0, 0.619275,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457005,-99) , 
2, 3.28134, 0, 0, 0.462725,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.973131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12712,-99) , 
2, 3.56319, 1, 0, 0.27876,-99) , 
2, 3.49268, 1, 0, 0.454687,-99) , 
2, 3.70995, 0, 0, 0.461402,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.140679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.351049, 1, 1, 0.85378,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0527647,-99) , 
2, 0.329974, 0, 0, 0.524812,-99) , 
1, 2.64724, 0, 0, 0.529774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.528301,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.140103);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77116,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439874,-99) , 
3, 1.89992, 1, 0, 0.49335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0601881,-99) , 
2, 0.594056, 0, 0, 0.490754,-99) , 
1, 2.75463, 0, 0, 0.49367,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.102086);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745503,-99) , 
NN(
NN(
0, 
0, 
-1, -0.760756, 0, -1, 0.479419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0601881,-99) , 
2, 0.594056, 0, 0, 0.477071,-99) , 
1, 2.75463, 0, 0, 0.47977,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.209176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.69471, 0, 1, 0.651974,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461783,-99) , 
3, 1.85382, 1, 0, 0.496044,-99) , 
3, 1.92916, 0, 0, 0.506085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.504752,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.445817);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418096,-99) , 
3, 1.92144, 1, 0, 0.597125,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44397,-99) , 
1, 2.38519, 0, 0, 0.465631,-99) , 
2, 2.61296, 1, 0, 0.545844,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.777776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444055,-99) , 
1, 0.504012, 0, 0, 0.572426,-99) , 
NN(
0, 
0, 
-1, -1.79698, 0, -1, 0.404539,-99) , 
2, 2.58274, 0, 0, 0.470025,-99) , 
3, 1.86051, 0, 0, 0.514043,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.30059);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.281119,-99) , 
0, 0.683692, 1, 0, 0.937342,-99) , 
NN(
0, 
0, 
-1, -0.0948589, 1, 1, 0.567299,-99) , 
1, -1.18549, 1, 0, 0.603919,-99) , 
NN(
NN(
0, 
0, 
-1, 1.80043, 0, 1, 0.540241,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.773391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.12014,-99) , 
1, 2.58594, 0, 0, 0.307386,-99) , 
1, 2.19166, 1, 0, 0.524498,-99) , 
2, 2.77518, 0, 0, 0.547445,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.29329);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.905174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.232519,-99) , 
3, 1.82605, 0, 0, 0.847391,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0201838,-99) , 
1, 1.65296, 0, 0, 0.106193,-99) , 
1, 1.10357, 1, 0, 0.656275,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524779,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434778,-99) , 
2, 2.24534, 0, 0, 0.477248,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.173278,-99) , 
2, 3.56319, 1, 0, 0.315201,-99) , 
2, 3.49268, 1, 0, 0.470557,-99) , 
2, 3.70995, 0, 0, 0.477852,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.380244);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.61679, 0, 1, 0.595311,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331999,-99) , 
3, 1.87575, 1, 0, 0.484306,-99) , 
3, 1.89268, 0, 0, 0.5232,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.766686,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.154833,-99) , 
1, 1.10357, 1, 0, 0.639313,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384269,-99) , 
0, 0.716027, 0, 0, 0.4102,-99) , 
2, 3.61442, 0, 0, 0.43276,-99) , 
2, 2.46359, 1, 0, 0.481946,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.446706);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -1.11582, 1, 1, 0.627942,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559855,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388018,-99) , 
1, 0.597841, 0, 0, 0.452033,-99) , 
2, 2.8532, 0, 0, 0.491561,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443632,-99) , 
3, 1.93737, 0, 0, 0.459808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.134162,-99) , 
1, 1.91732, 0, 0, 0.276019,-99) , 
1, 0.736791, 1, 0, 0.405854,-99) , 
0, 0.572659, 1, 0, 0.468034,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.408147);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.196368, 0, 1, 0.68257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37063,-99) , 
0, 0.199185, 0, 0, 0.495935,-99) , 
0, -0.0349378, 1, 0, 0.517732,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347798,-99) , 
0, 0.300749, 1, 0, 0.467098,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0558819,-99) , 
0, -0.24572, 1, 0, 0.169135,-99) , 
0, 0.0344758, 0, 0, 0.402136,-99) , 
1, 1.06572, 1, 0, 0.489038,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.472137);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.947335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0962751,-99) , 
2, 1.54767, 0, 0, 0.827216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.991583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287612,-99) , 
0, -0.0217585, 1, 0, 0.449062,-99) , 
1, -2.18614, 0, 0, 0.600409,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599981,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378891,-99) , 
1, 0.305195, 1, 0, 0.488495,-99) , 
NN(
0, 
0, 
-1, -1.05116, 0, -1, 0.408966,-99) , 
0, 0.268861, 1, 0, 0.435439,-99) , 
1, -1.74913, 1, 0, 0.447792,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.195064);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.9675, 0, 1, 0.530549,-99) , 
NN(
NN(
0, 
0, 
-1, 3.31572, 1, 1, 0.998302,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.958701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.20836,-99) , 
2, 1.30463, 1, 0, 0.293795,-99) , 
2, 2.83629, 0, 0, 0.372647,-99) , 
0, -0.186837, 0, 0, 0.521077,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.186188);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0911794, 1, 1, 0.672878,-99) , 
NN(
0, 
0, 
-1, 1.80488, 0, -1, 0.462928,-99) , 
3, 1.92893, 0, 0, 0.475272,-99) , 
3, 1.9675, 0, 0, 0.476836,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.172387);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.351049, 1, 1, 0.813619,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441414,-99) , 
2, 1.50451, 0, 0, 0.515347,-99) , 
1, 2.64724, 0, 0, 0.51913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78918, 0, 0, 0.517683,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.30041);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.879265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0361237,-99) , 
0, 0.899551, 1, 0, 0.769769,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557494,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00102927,-99) , 
0, 0.47215, 1, 0, 0.480353,-99) , 
0, 0.645594, 0, 0, 0.562426,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.94606,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.79483, 1, 0, 0.800115,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4283,-99) , 
1, 0.0854901, 0, 0, 0.473221,-99) , 
3, 1.79373, 1, 0, 0.479078,-99) , 
2, 1.21723, 1, 0, 0.491393,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.368422);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.916639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275918,-99) , 
1, -0.761471, 0, 0, 0.729542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443012,-99) , 
3, 1.87564, 0, 0, 0.525307,-99) , 
0, 1.02807, 0, 0, 0.544233,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999506,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438494,-99) , 
0, -0.246429, 1, 0, 0.448869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.97275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0370087,-99) , 
0, -0.39685, 1, 0, 0.139348,-99) , 
0, -0.321065, 0, 0, 0.439611,-99) , 
1, -0.060221, 1, 0, 0.483355,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.216195);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.15707, 1, 1, 0.999577,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.805447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.330291,-99) , 
1, -2.19821, 0, 0, 0.537296,-99) , 
2, 3.01974, 0, 0, 0.652898,-99) , 
NN(
NN(
0, 
0, 
-1, 2.59739, 0, 1, 0.528677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.163227,-99) , 
2, 2.8368, 0, 0, 0.275554,-99) , 
1, -1.40067, 0, 0, 0.522649,-99) , 
1, -1.74913, 1, 0, 0.531317,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.186846);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.15707, 1, 1, 0.999475,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454554,-99) , 
3, 1.92796, 0, 0, 0.546517,-99) , 
2, 3.01974, 0, 0, 0.654497,-99) , 
NN(
NN(
0, 
0, 
-1, -1.40067, 0, -1, 0.478986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242304,-99) , 
3, 1.89692, 0, 0, 0.329,-99) , 
0, -0.186837, 0, 0, 0.4708,-99) , 
1, -1.74913, 1, 0, 0.482378,-99)    );
   return;
};
 
// Clean up
inline void ReadCUTS_25::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadCUTS_25::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
