// Class: ReadCUTS_15
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::CUTS_15
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/09       [336393]
Creator        : jlang
Date           : Tue Dec  8 16:22:08 2015
Host           : Linux ekpams2 2.6.32-504.16.2.el6.x86_64 #1 SMP Tue Apr 21 21:44:51 CEST 2015 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /usr/users/jlang/BDT/Test/BDT_Training
Training events: 1332
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "True" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "10" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "15" [Number of steps during node cut optimisation]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Verbose" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "2" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "1332" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
v0                            v0                            v0                            v0                                                              'F'    [-0.490635514259,1.48405468464]
v1                            v1                            v1                            v1                                                              'F'    [-7.37883806229,7.25839614868]
v2                            v2                            v2                            v2                                                              'F'    [-1.8986569643,6.2026591301]
v3                            v3                            v3                            v3                                                              'F'    [1.46819293499,2.39548110962]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new CUTS_15Node
   
#ifndef CUTS_15Node__def
#define CUTS_15Node__def
   
class CUTS_15Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   CUTS_15Node ( CUTS_15Node* left,CUTS_15Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~CUTS_15Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   CUTS_15Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   CUTS_15Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   CUTS_15Node*   fLeft;     // pointer to the left daughter node
   CUTS_15Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   CUTS_15Node::~CUTS_15Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool CUTS_15Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool CUTS_15Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadCUTS_15 : public IClassifierReader {

 public:

   // constructor
   ReadCUTS_15( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadCUTS_15" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "v0", "v1", "v2", "v3" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = -0.490635514259338;
      fVmax[0] = 1.48405468463898;
      fVmin[1] = -7.37883806228638;
      fVmax[1] = 7.25839614868164;
      fVmin[2] = -1.89865696430206;
      fVmax[2] = 6.20265913009644;
      fVmin[3] = 1.46819293498993;
      fVmax[3] = 2.39548110961914;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadCUTS_15() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<CUTS_15Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadCUTS_15::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      CUTS_15Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(CUTS_15Node*)current->GetRight();
         else current=(CUTS_15Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadCUTS_15::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(2.5552874465498);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.96842, 0, 1, 0.997976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.280702,-99) , 
0, 0.58257, 1, 0, 0.587209,-99) , 
3, 1.9393, 0, 0, 0.891892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.118644,-99) , 
0, 0.602996, 1, 0, 0.423611,-99) , 
NN(
0, 
0, 
-1, 1.79972, 0, -1, 0.0210728,-99) , 
3, 1.82237, 0, 0, 0.108108,-99) , 
3, 1.87388, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.36938);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.987076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437158,-99) , 
0, 0.384737, 0, 0, 0.782741,-99) , 
3, 1.96085, 0, 0, 0.9549,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515352,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79441, 0, 0, 0.419511,-99) , 
NN(
0, 
0, 
-1, 1.78556, 0, -1, 0.119252,-99) , 
2, 1.77287, 0, 0, 0.267913,-99) , 
3, 1.93184, 0, 0, 0.432747,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.65573);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.96085, 0, 1, 0.954663,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0415139,-99) , 
3, 1.81858, 0, 0, 0.435238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.91932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.164583,-99) , 
1, 2.56229, 0, 0, 0.187896,-99) , 
0, 0.628503, 0, 0, 0.254077,-99) , 
3, 1.93184, 0, 0, 0.370443,-99)    );
  // itree = 3
  fBoostWeights.push_back(1.18019);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.861487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78118, 0, 0, 0.642533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.319754,-99) , 
0, -0.236822, 1, 0, 0.352214,-99) , 
3, 1.8264, 1, 0, 0.438748,-99) , 
3, 1.98979, 0, 0, 0.474613,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.746077);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.95774, 0, 1, 0.651696,-99) , 
NN(
0, 
0, 
-1, -0.552492, 1, -1, 0.113117,-99) , 
0, 1.1135, 1, 0, 0.62445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.597109,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.619093);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.595649, 1, 1, 0.946946,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.192607,-99) , 
3, 1.96097, 0, 0, 0.498372,-99) , 
2, 2.16425, 0, 0, 0.763414,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544202,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36695,-99) , 
3, 1.88601, 0, 0, 0.426865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.408854,-99) , 
3, 1.93184, 0, 0, 0.444608,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.36101);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424523,-99) , 
1, 0.158094, 1, 0, 0.596575,-99) , 
3, 1.96085, 0, 0, 0.753511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.942718,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.443336,-99) , 
2, 4.52652, 0, 0, 0.458767,-99) , 
3, 1.93184, 0, 0, 0.483204,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.331039);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.95774, 0, 1, 0.573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.560907,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.384322);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.73606, 0, 1, 0.997521,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476324,-99) , 
1, -1.0673, 1, 0, 0.50726,-99) , 
2, 4.462, 0, 0, 0.522204,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.953654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.80301, 0, 0, 0.878229,-99) , 
NN(
0, 
0, 
-1, -0.135162, 1, -1, 0.305662,-99) , 
0, 0.790001, 1, 0, 0.343051,-99) , 
0, 0.743546, 1, 0, 0.481869,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.418718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.373856, 1, 1, 0.698948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.913691,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484272,-99) , 
3, 1.93532, 0, 0, 0.512429,-99) , 
2, 1.67752, 1, 0, 0.565723,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.864063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0503302,-99) , 
3, 1.92805, 0, 0, 0.0907232,-99) , 
1, 1.70281, 0, 0, 0.221145,-99) , 
2, 0.633004, 0, 0, 0.549532,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.479487);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.86257, 0, 1, 0.606505,-99) , 
NN(
0, 
0, 
-1, 1.86531, 0, -1, 0.0322885,-99) , 
0, 1.2369, 1, 0, 0.598551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.589125,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.341991);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.868773, 1, 1, 0.847704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.157221,-99) , 
0, 0.795603, 1, 0, 0.718383,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461437,-99) , 
3, 1.98979, 0, 0, 0.468189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.752629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.024444,-99) , 
1, 1.71695, 0, 0, 0.143159,-99) , 
2, 0.534529, 0, 0, 0.454894,-99) , 
2, 3.671, 0, 0, 0.477146,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.4269);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.831373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.752706, 1, 0, 0.70899,-99) , 
NN(
0, 
0, 
-1, 1.9646, 0, 1, 0.531752,-99) , 
3, 1.82028, 1, 0, 0.564226,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119807,-99) , 
3, 1.85792, 1, 0, 0.506856,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0261669,-99) , 
0, 0.128284, 1, 0, 0.18436,-99) , 
2, 0.633004, 0, 0, 0.548695,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.529641);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.821759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.3556, 0, 0, 0.736823,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.630815, 1, 0, 0.603024,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.384275,-99) , 
3, 1.85195, 1, 0, 0.423563,-99) , 
3, 1.96104, 0, 0, 0.43308,-99) , 
3, 1.81593, 1, 0, 0.453635,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.10475);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0499562, 0, 1, 0.998367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76276, 0, 0, 0.497162,-99) , 
2, 4.81031, 0, 0, 0.503033,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.957752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.313699,-99) , 
2, 0.285015, 0, 0, 0.440381,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0231669,-99) , 
0, 0.128284, 1, 0, 0.16654,-99) , 
2, 0.633004, 0, 0, 0.492607,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.178941);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0499562, 0, 1, 0.998187,-99) , 
NN(
0, 
0, 
-1, 1.76276, 0, -1, 0.471548,-99) , 
2, 4.81031, 0, 0, 0.477404,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.953304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336678,-99) , 
2, 0.285015, 0, 0, 0.455126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0231669,-99) , 
0, 0.128284, 1, 0, 0.17438,-99) , 
2, 0.633004, 0, 0, 0.468394,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.165522);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.96147, 0, 1, 0.526126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76276, 0, 0, 0.521155,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.739478,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0579974,-99) , 
3, 1.92805, 0, 0, 0.0957948,-99) , 
1, 1.70281, 0, 0, 0.189388,-99) , 
2, 0.633004, 0, 0, 0.511924,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.144393);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480545,-99) , 
2, 4.81031, 0, 0, 0.485468,-99) , 
NN(
0, 
0, 
-1, 0.17057, 1, -1, 0.197917,-99) , 
2, 0.633004, 0, 0, 0.478101,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.028945,-99) , 
0, 1.23722, 1, 0, 0.473097,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.105353);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.95774, 0, 1, 0.517744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.513532,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0332915,-99) , 
0, 1.23722, 1, 0, 0.508519,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.294786);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48117,-99) , 
1, -1.78392, 1, 0, 0.507499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.186877,-99) , 
0, 0.373856, 1, 0, 0.38261,-99) , 
2, 1.47524, 0, 0, 0.479069,-99) , 
3, 1.98979, 0, 0, 0.483131,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.41632);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -1.6108, 1, 1, 0.562952,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.764543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0132424,-99) , 
0, 0.58452, 1, 0, 0.665419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.127935,-99) , 
3, 1.87582, 0, 0, 0.339878,-99) , 
1, 0.854606, 0, 0, 0.433441,-99) , 
2, 1.64567, 0, 0, 0.528681,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.420628);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.182393,-99) , 
0, 0.799284, 1, 0, 0.551532,-99) , 
NN(
0, 
0, 
-1, -0.243799, 0, -1, 0.425456,-99) , 
2, 3.06987, 0, 0, 0.450318,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.9546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271228,-99) , 
2, 0.285015, 0, 0, 0.410272,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92805, 0, 0, 0.0211108,-99) , 
0, 0.128284, 1, 0, 0.174804,-99) , 
2, 0.633004, 0, 0, 0.443447,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.225243);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.990105, 0, 1, 0.571667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0523915,-99) , 
0, 0.995168, 1, 0, 0.483039,-99) , 
1, -0.060221, 1, 0, 0.522374,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73047,-99) , 
NN(
0, 
0, 
-1, -0.109412, 1, -1, 0.108164,-99) , 
1, 1.70281, 0, 0, 0.209666,-99) , 
2, 0.633004, 0, 0, 0.515614,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.197327);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460809,-99) , 
3, 1.94648, 0, 0, 0.465015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76127, 0, 0, 0.461239,-99) , 
3, 1.98979, 0, 0, 0.464414,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.140239);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639553,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49083,-99) , 
3, 1.82019, 1, 0, 0.51122,-99) , 
3, 1.95774, 0, 0, 0.516019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.51237,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.234718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331096,-99) , 
2, 0.806639, 0, 0, 0.536764,-99) , 
3, 1.95774, 0, 0, 0.541013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.537437,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.318843);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.826286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00179118,-99) , 
1, -0.550042, 1, 0, 0.737735,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.70074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46541,-99) , 
0, -0.0287254, 1, 0, 0.499064,-99) , 
0, 0.990105, 0, 0, 0.532508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.985372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459845,-99) , 
2, 4.3955, 0, 0, 0.465573,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.065106,-99) , 
0, 0.995168, 1, 0, 0.446473,-99) , 
1, -0.060221, 1, 0, 0.484554,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.33021);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.0778765, 1, 1, 0.564231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260951,-99) , 
3, 1.89005, 0, 0, 0.363399,-99) , 
0, -0.167017, 0, 0, 0.549949,-99) , 
NN(
0, 
0, 
-1, 1.42257, 0, -1, 0.0456507,-99) , 
0, 1.23722, 1, 0, 0.546487,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.254597);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.896254,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288299,-99) , 
1, -2.19348, 0, 0, 0.525171,-99) , 
NN(
0, 
0, 
-1, 0.995168, 1, -1, 0.442578,-99) , 
1, -0.464668, 1, 0, 0.471756,-99) , 
1, 2.68426, 0, 0, 0.475087,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.204828);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448411,-99) , 
1, 0.0210093, 0, 0, 0.495767,-99) , 
3, 1.95774, 0, 0, 0.500282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.497325,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0558695);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.23929, 1, -1, 0.492657,-99) , 
3, 1.95774, 0, 0, 0.496777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.494113,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0721252);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.506624,-99) , 
3, 1.95774, 0, 0, 0.51052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.507857,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0883956);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486333,-99) , 
3, 1.94304, 0, 0, 0.488771,-99) , 
3, 1.95774, 0, 0, 0.492668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.490187,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0846518);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.510661,-99) , 
3, 1.95774, 0, 0, 0.514233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.511753,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0827436);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487261,-99) , 
2, 4.83589, 0, 0, 0.489693,-99) , 
3, 1.95774, 0, 0, 0.493266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.490984,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.062572);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.95774, 0, 1, 0.513476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.511195,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0660158);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.905318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491601,-99) , 
1, 2.65279, 0, 0, 0.494543,-99) , 
3, 1.95774, 0, 0, 0.497837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.495692,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0806013);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.510814,-99) , 
3, 1.95774, 0, 0, 0.5139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.511757,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.444401);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.731473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469725,-99) , 
0, 0.620923, 1, 0, 0.549199,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56716,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.306569,-99) , 
0, 0.311357, 1, 0, 0.478149,-99) , 
0, 0.49671, 0, 0, 0.505629,-99) , 
NN(
NN(
0, 
0, 
-1, 3.38902, 0, 1, 0.999397,-99) , 
NN(
0, 
0, 
-1, 1.00741, 1, -1, 0.379632,-99) , 
1, -1.26528, 1, 0, 0.417725,-99) , 
2, 3.16467, 1, 0, 0.491942,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.50476);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.843146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484255,-99) , 
2, 2.55442, 1, 0, 0.704931,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55835,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.227854,-99) , 
0, 0.400757, 0, 0, 0.519436,-99) , 
0, 0.327399, 1, 0, 0.546058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.999211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0164141,-99) , 
2, 1.56296, 0, 0, 0.933217,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365983,-99) , 
3, 1.93532, 0, 0, 0.383215,-99) , 
0, 0.200607, 0, 0, 0.416762,-99) , 
0, 0.249873, 0, 0, 0.503104,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.456321);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.957188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355887,-99) , 
1, 1.27313, 1, 0, 0.746548,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348083,-99) , 
2, 2.43567, 1, 0, 0.476334,-99) , 
2, 2.89658, 0, 0, 0.536478,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422656,-99) , 
3, 1.91838, 0, 0, 0.449354,-99) , 
NN(
0, 
0, 
-1, 0.584124, 1, -1, 0.117169,-99) , 
3, 1.81062, 0, 0, 0.43279,-99) , 
0, 0.373291, 1, 0, 0.479374,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.470343);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717448,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.131447,-99) , 
0, -0.364097, 0, 0, 0.674511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.763736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440491,-99) , 
0, 0.446559, 1, 0, 0.490378,-99) , 
0, 0.377671, 1, 0, 0.571888,-99) , 
NN(
NN(
0, 
0, 
-1, 0.621074, 1, 1, 0.567295,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.997613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394429,-99) , 
0, -0.367252, 1, 0, 0.408755,-99) , 
0, 0.49671, 0, 0, 0.472053,-99) , 
2, 2.65833, 0, 0, 0.506958,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.439104);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.194624,-99) , 
0, -0.348006, 0, 0, 0.609267,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.909944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.100196,-99) , 
2, 2.96693, 0, 0, 0.348044,-99) , 
1, -1.26528, 0, 0, 0.578244,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480343,-99) , 
1, 0.597841, 0, 0, 0.540192,-99) , 
NN(
0, 
0, 
-1, 0.863598, 1, -1, 0.385481,-99) , 
0, 0.620128, 1, 0, 0.491653,-99) , 
2, 2.65833, 0, 0, 0.52139,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.41702);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.838263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451957,-99) , 
0, -0.182203, 0, 0, 0.713855,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544386,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0206498,-99) , 
2, 0.633004, 0, 0, 0.53878,-99) , 
0, 0.00294468, 1, 0, 0.563379,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396693,-99) , 
2, 2.44683, 0, 0, 0.490644,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.720177,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.127732,-99) , 
2, 1.70868, 1, 0, 0.266625,-99) , 
0, 0.017395, 0, 0, 0.434798,-99) , 
1, 0.854606, 1, 0, 0.526597,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.312292);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.25231, 0, 1, 0.98862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.787838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418116,-99) , 
0, -0.167671, 0, 0, 0.540814,-99) , 
1, -1.11829, 1, 0, 0.604325,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.798283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461048,-99) , 
0, -0.0166225, 1, 0, 0.473956,-99) , 
NN(
0, 
0, 
-1, 0.816872, 1, -1, 0.346558,-99) , 
2, 3.16467, 1, 0, 0.453933,-99) , 
0, -0.120381, 1, 0, 0.467661,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.200776);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.920241,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76276, 0, 0, 0.536635,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.81684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0373905,-99) , 
1, -1.75912, 1, 0, 0.217048,-99) , 
2, 0.633004, 0, 0, 0.531931,-99) , 
1, 2.68426, 0, 0, 0.535382,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.202231);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.904205,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.866973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347771,-99) , 
1, -2.08063, 0, 0, 0.613073,-99) , 
NN(
0, 
0, 
-1, -1.44448, 0, -1, 0.471716,-99) , 
1, -1.72179, 1, 0, 0.483312,-99) , 
1, 2.68426, 0, 0, 0.486773,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.291919);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.801269,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422125,-99) , 
2, 1.89805, 1, 0, 0.66057,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0446054,-99) , 
2, 0.316249, 0, 0, 0.532785,-99) , 
1, 1.76943, 0, 0, 0.546289,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.993693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488337,-99) , 
1, -0.746633, 1, 0, 0.535135,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92315, 0, 0, 0.137899,-99) , 
0, 0.799284, 1, 0, 0.453697,-99) , 
2, 3.16467, 1, 0, 0.532471,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.31697);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.79791, 0, 1, 0.706727,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.974082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.276703,-99) , 
1, 2.53317, 0, 0, 0.380049,-99) , 
0, 0.18379, 0, 0, 0.619624,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.822644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0459246,-99) , 
1, 1.01558, 1, 0, 0.626773,-99) , 
NN(
0, 
0, 
-1, 0.534529, 0, -1, 0.458505,-99) , 
2, 3.671, 0, 0, 0.469849,-99) , 
1, 1.76943, 0, 0, 0.484888,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.361);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.07439, 0, 1, 0.573536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.78513, 1, 0, 0.462172,-99) , 
3, 1.83836, 0, 0, 0.54743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.545267,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.229234);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392951,-99) , 
3, 1.83833, 0, 0, 0.475704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237116,-99) , 
0, 0.67575, 0, 0, 0.322563,-99) , 
3, 1.92409, 1, 0, 0.461059,-99) , 
3, 1.98979, 0, 0, 0.462653,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.501749);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.93827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383292,-99) , 
2, 1.97054, 1, 0, 0.640619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.52829, 0, 0, 0.552177,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.755741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0771691,-99) , 
1, -0.552492, 1, 0, 0.580173,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413504,-99) , 
0, -0.393817, 1, 0, 0.417974,-99) , 
0, 1.07439, 0, 0, 0.429227,-99) , 
3, 1.81593, 1, 0, 0.441081,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.383667);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.73606, 0, 1, 0.989984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355144,-99) , 
2, 0.793772, 0, 0, 0.562796,-99) , 
2, 4.462, 0, 0, 0.566266,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.852095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454099,-99) , 
0, 0.777611, 1, 0, 0.528069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00510259,-99) , 
1, 0.657236, 1, 0, 0.317334,-99) , 
0, 0.675559, 0, 0, 0.489048,-99) , 
0, 0.620128, 1, 0, 0.544154,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.292894);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677093,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34341,-99) , 
2, 1.55989, 0, 0, 0.626161,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622164,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.90236, 0, 0, 0.219237,-99) , 
2, 3.16467, 1, 0, 0.58238,-99) , 
NN(
NN(
0, 
0, 
-1, 4.73606, 0, 1, 0.988301,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.99872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465819,-99) , 
0, -0.413526, 1, 0, 0.468664,-99) , 
2, 4.462, 0, 0, 0.472695,-99) , 
0, 0.743546, 0, 0, 0.495789,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.297499);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.887868,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0780199, 1, 1, 0.773212,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426854,-99) , 
1, -0.770311, 0, 0, 0.536059,-99) , 
1, -2.35035, 1, 0, 0.540835,-99) , 
1, 2.68426, 0, 0, 0.543605,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.202461);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.36724, 1, 1, 0.540291,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582834,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461243,-99) , 
0, 0.713042, 0, 0, 0.481208,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.0861842,-99) , 
0, 0.995168, 1, 0, 0.467491,-99) , 
1, -0.060221, 1, 0, 0.500289,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.153904);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.857424,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.859543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407163,-99) , 
1, -2.08063, 0, 0, 0.634356,-99) , 
NN(
0, 
0, 
-1, -1.44448, 0, -1, 0.481093,-99) , 
1, -1.72179, 1, 0, 0.493609,-99) , 
1, 2.68426, 0, 0, 0.496458,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.366189);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.820125,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422234,-99) , 
1, 0.384042, 1, 0, 0.629691,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481195,-99) , 
1, 0.597841, 0, 0, 0.534758,-99) , 
0, -0.0742541, 1, 0, 0.550503,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.783501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450133,-99) , 
0, 0.777611, 1, 0, 0.507293,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.010525,-99) , 
1, 0.657236, 1, 0, 0.335913,-99) , 
0, 0.675559, 0, 0, 0.478546,-99) , 
0, 0.620128, 1, 0, 0.531317,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.299435);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459022,-99) , 
3, 1.91847, 1, 0, 0.557492,-99) , 
3, 1.95774, 0, 0, 0.560877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.75797, 0, 0, 0.559183,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.223623);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.615158, 1, 1, 0.871181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286056,-99) , 
0, 0.380917, 0, 0, 0.416918,-99) , 
2, 2.16425, 0, 0, 0.668008,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394709,-99) , 
1, 1.3369, 1, 0, 0.501032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.496895,-99) , 
3, 1.93184, 0, 0, 0.507435,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.214044);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420677,-99) , 
1, -0.126828, 1, 0, 0.533025,-99) , 
2, 3.06167, 0, 0, 0.664918,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.459184,-99) , 
3, 1.93184, 0, 0, 0.47109,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.179831);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.778134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361484,-99) , 
2, 1.79735, 0, 0, 0.56799,-99) , 
2, 3.06167, 0, 0, 0.68331,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346641,-99) , 
2, 4.1551, 1, 0, 0.516043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.512601,-99) , 
3, 1.93184, 0, 0, 0.522047,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.152164);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477491,-99) , 
1, -0.126828, 1, 0, 0.571027,-99) , 
2, 3.06167, 0, 0, 0.680899,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.471555,-99) , 
3, 1.93184, 0, 0, 0.482634,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.130028);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425313,-99) , 
0, 0.186511, 1, 0, 0.591815,-99) , 
0, 0.713232, 0, 0, 0.695493,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.512468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.509564,-99) , 
3, 1.93184, 0, 0, 0.519147,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.135174);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457361,-99) , 
0, 0.186511, 1, 0, 0.608248,-99) , 
0, 0.713232, 0, 0, 0.704732,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.477679,-99) , 
3, 1.93184, 0, 0, 0.489012,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.117893);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.714998,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.51401,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.511456,-99) , 
3, 1.93184, 0, 0, 0.521316,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.118463);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.690379,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.887631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482618,-99) , 
2, 4.58487, 0, 0, 0.48475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.482478,-99) , 
3, 1.93184, 0, 0, 0.492329,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.261256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34012,-99) , 
0, -0.0233701, 0, 0, 0.545129,-99) , 
0, -0.249862, 1, 0, 0.555877,-99) , 
NN(
NN(
0, 
0, 
-1, 3.91427, 0, 1, 0.517432,-99) , 
NN(
0, 
0, 
-1, 0.700305, 1, -1, 0.360569,-99) , 
0, 0.630815, 1, 0, 0.480787,-99) , 
3, 1.87388, 0, 0, 0.518877,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.350169);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.889535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353091,-99) , 
1, 2.46057, 1, 0, 0.740358,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00283836,-99) , 
2, 2.28668, 0, 0, 0.371422,-99) , 
2, 2.04813, 1, 0, 0.570972,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.715858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189182,-99) , 
2, 1.41624, 0, 0, 0.600873,-99) , 
NN(
0, 
0, 
-1, 1.54967, 1, -1, 0.450743,-99) , 
1, -1.66499, 1, 0, 0.463856,-99) , 
1, 1.76943, 0, 0, 0.474121,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.220688);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.674071,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462133,-99) , 
1, 1.3369, 1, 0, 0.535991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.53342,-99) , 
3, 1.93184, 0, 0, 0.540011,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.225598);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.983824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45339,-99) , 
2, 1.3693, 1, 0, 0.888324,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484711,-99) , 
1, 0.635538, 1, 0, 0.534216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.783085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458088,-99) , 
2, 3.671, 0, 0, 0.470372,-99) , 
1, 0.163893, 0, 0, 0.497708,-99) , 
1, 2.68426, 0, 0, 0.500613,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.321307);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.898567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49847,-99) , 
1, 2.46057, 1, 0, 0.800983,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60224,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00503687,-99) , 
2, 2.28668, 0, 0, 0.429622,-99) , 
2, 2.04813, 1, 0, 0.642725,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.172077,-99) , 
1, -2.1497, 0, 0, 0.559981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.829305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487253,-99) , 
2, 3.82056, 0, 0, 0.50225,-99) , 
3, 1.87388, 0, 0, 0.531685,-99) , 
1, 1.76943, 0, 0, 0.541904,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.305371);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.79101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403061,-99) , 
1, 0.99395, 1, 0, 0.705551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.43191, 0, 0, 0.556791,-99) , 
2, 1.18092, 1, 0, 0.578034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.225373,-99) , 
2, 3.9591, 1, 0, 0.488171,-99) , 
0, -0.249862, 1, 0, 0.499695,-99) , 
3, 1.87388, 1, 0, 0.538673,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.310173);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.751583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379195,-99) , 
3, 1.84448, 1, 0, 0.676444,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 1.43191, 0, 0, 0.488097,-99) , 
2, 1.18092, 1, 0, 0.513959,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415465,-99) , 
3, 1.97188, 0, 0, 0.419409,-99) , 
0, -0.249862, 1, 0, 0.430587,-99) , 
3, 1.87388, 1, 0, 0.47142,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.149169);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.3693, 1, 1, 0.910902,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.998602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492435,-99) , 
0, -0.367217, 1, 0, 0.497156,-99) , 
NN(
0, 
0, 
-1, 2.88655, 0, -1, 0.423382,-99) , 
2, 2.65833, 1, 0, 0.471831,-99) , 
1, 2.68426, 0, 0, 0.475265,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.423329);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759809,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32568,-99) , 
1, -2.17772, 0, 0, 0.636885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606912,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489621,-99) , 
2, 1.23317, 1, 0, 0.517019,-99) , 
1, -0.975048, 1, 0, 0.537404,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.35663,-99) , 
0, 0.4833, 1, 0, 0.511671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.733853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.299032,-99) , 
0, 0.747942, 0, 0, 0.375358,-99) , 
2, 2.88655, 0, 0, 0.461104,-99) , 
2, 2.65833, 1, 0, 0.511518,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.425994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.59281, 1, 1, 0.622559,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.711318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370325,-99) , 
1, 0.854606, 0, 0, 0.479057,-99) , 
2, 1.51788, 0, 0, 0.578018,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.9818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297251,-99) , 
1, -1.04947, 0, 0, 0.478339,-99) , 
1, 2.36524, 0, 0, 0.486598,-99) , 
2, 2.65833, 1, 0, 0.547974,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.259099);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.390889, 0, 1, 0.99868,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322366,-99) , 
1, -1.88988, 0, 0, 0.513164,-99) , 
0, -0.367217, 1, 0, 0.518494,-99) , 
NN(
NN(
0, 
0, 
-1, 3.17293, 0, 1, 0.880941,-99) , 
NN(
0, 
0, 
-1, 3.54977, 1, -1, 0.398605,-99) , 
1, -1.78392, 1, 0, 0.411606,-99) , 
2, 2.65833, 1, 0, 0.482486,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.193504);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.955157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468028,-99) , 
2, 1.3693, 1, 0, 0.831593,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454009,-99) , 
0, 0.0780199, 1, 0, 0.693508,-99) , 
NN(
0, 
0, 
-1, 0.633004, 0, -1, 0.458001,-99) , 
1, -2.35035, 1, 0, 0.463182,-99) , 
1, 2.68426, 0, 0, 0.46533,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.118826);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438107,-99) , 
1, -0.126828, 1, 0, 0.5321,-99) , 
2, 3.06167, 0, 0, 0.636203,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585842,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494906,-99) , 
0, 0.0173027, 1, 0, 0.509195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.506273,-99) , 
3, 1.93184, 0, 0, 0.512325,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.193188);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.848934, 1, 1, 0.705405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00550519,-99) , 
0, 1.2061, 1, 0, 0.546406,-99) , 
0, 0.00294468, 1, 0, 0.563144,-99) , 
NN(
NN(
0, 
0, 
-1, 0.895278, 0, 1, 0.519909,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.90173, 0, 0, 0.105915,-99) , 
0, 0.995168, 1, 0, 0.507903,-99) , 
1, -0.060221, 1, 0, 0.532296,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.218164);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.869341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454383,-99) , 
1, -0.848934, 1, 0, 0.663735,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486794,-99) , 
3, 1.80849, 1, 0, 0.498958,-99) , 
0, 0.00294468, 1, 0, 0.515844,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454138,-99) , 
0, 0.895278, 0, 0, 0.471653,-99) , 
NN(
0, 
0, 
-1, 1.90173, 0, -1, 0.103855,-99) , 
0, 0.995168, 1, 0, 0.461764,-99) , 
1, -0.060221, 1, 0, 0.485544,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.201007);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40867,-99) , 
0, 0.186511, 1, 0, 0.557094,-99) , 
0, 0.713232, 0, 0, 0.648712,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341673,-99) , 
3, 1.80463, 0, 0, 0.525977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.522955,-99) , 
3, 1.93184, 0, 0, 0.528671,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.157972);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.778205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392792,-99) , 
2, 1.79735, 0, 0, 0.578053,-99) , 
2, 3.06167, 0, 0, 0.666726,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475629,-99) , 
3, 1.79558, 1, 0, 0.479404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.476905,-99) , 
3, 1.93184, 0, 0, 0.485171,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.113844);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497586,-99) , 
1, -0.126828, 1, 0, 0.582025,-99) , 
2, 3.06167, 0, 0, 0.666324,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518645,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.517271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.514776,-99) , 
3, 1.93184, 0, 0, 0.52115,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0805517);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.67911,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.486736,-99) , 
3, 1.93184, 0, 0, 0.494697,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.104047);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.661309,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368817,-99) , 
3, 1.80463, 0, 0, 0.509102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.506871,-99) , 
3, 1.93184, 0, 0, 0.51318,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.105365);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479908,-99) , 
1, -0.126828, 1, 0, 0.556945,-99) , 
2, 3.06167, 0, 0, 0.637629,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.887304,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48313,-99) , 
2, 4.58487, 0, 0, 0.48487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.482851,-99) , 
3, 1.93184, 0, 0, 0.489085,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0942441);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442339,-99) , 
0, 0.186511, 1, 0, 0.573806,-99) , 
0, 0.713232, 0, 0, 0.65061,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.510982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.508962,-99) , 
3, 1.93184, 0, 0, 0.514583,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.079938);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.659925,-99) , 
NN(
0, 
0, 
-1, 1.78653, 0, -1, 0.485696,-99) , 
3, 1.93184, 0, 0, 0.49248,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0673979);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496565,-99) , 
1, -0.126828, 1, 0, 0.567222,-99) , 
2, 3.06167, 0, 0, 0.641762,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, -0.142538, 0, 0, 0.507517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.505677,-99) , 
3, 1.93184, 0, 0, 0.510916,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0853161);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455198,-99) , 
0, 0.186511, 1, 0, 0.578429,-99) , 
0, 0.713232, 0, 0, 0.650375,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.8672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489229,-99) , 
2, 4.58487, 0, 0, 0.490747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.489026,-99) , 
3, 1.93184, 0, 0, 0.495184,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0876033);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484328,-99) , 
1, -0.0401001, 1, 0, 0.588407,-99) , 
1, 1.35714, 0, 0, 0.659241,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.23929, 1, 0, 0.511904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.510184,-99) , 
3, 1.93184, 0, 0, 0.515782,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.233584);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.06167, 0, 1, 0.668941,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417123,-99) , 
0, 0.261838, 0, 0, 0.530743,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506196,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373483,-99) , 
0, 0.629221, 1, 0, 0.469584,-99) , 
2, 1.77287, 1, 0, 0.488523,-99) , 
3, 1.93184, 0, 0, 0.495205,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.229099);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480736,-99) , 
1, -0.126828, 1, 0, 0.544385,-99) , 
2, 3.06167, 0, 0, 0.61534,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643237,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478156,-99) , 
0, 0.017395, 1, 0, 0.51171,-99) , 
NN(
0, 
0, 
-1, 0.0204669, 0, -1, 0.443004,-99) , 
2, 1.77287, 1, 0, 0.464119,-99) , 
3, 1.93184, 0, 0, 0.469573,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.183625);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.974683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42787,-99) , 
2, 1.3693, 1, 0, 0.856454,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53062,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30677,-99) , 
2, 0.633004, 0, 0, 0.527653,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.225487,-99) , 
1, 1.89511, 0, 0, 0.434417,-99) , 
1, 1.42102, 1, 0, 0.516913,-99) , 
1, 2.68426, 0, 0, 0.518911,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.163594);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.969735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473295,-99) , 
2, 1.3693, 1, 0, 0.855721,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.777904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434193,-99) , 
1, -2.08063, 0, 0, 0.578839,-99) , 
NN(
0, 
0, 
-1, -1.44448, 0, -1, 0.468806,-99) , 
1, -1.72179, 1, 0, 0.475735,-99) , 
1, 2.68426, 0, 0, 0.47783,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0789111);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493729,-99) , 
1, -0.0401001, 1, 0, 0.574325,-99) , 
1, 1.35714, 0, 0, 0.650266,-99) , 
NN(
NN(
0, 
0, 
-1, 4.58487, 0, 1, 0.512888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.511209,-99) , 
3, 1.93184, 0, 0, 0.516248,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.065951);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.35714, 0, 1, 0.659794,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.868469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491746,-99) , 
2, 4.58487, 0, 0, 0.493163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.491611,-99) , 
3, 1.93184, 0, 0, 0.497639,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0712843);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496969,-99) , 
1, -0.0401001, 1, 0, 0.572296,-99) , 
1, 1.35714, 0, 0, 0.644838,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, -0.142538, 0, 0, 0.509527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78653, 0, 0, 0.507975,-99) , 
3, 1.93184, 0, 0, 0.512834,-99)    );
   return;
};
 
// Clean up
inline void ReadCUTS_15::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadCUTS_15::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
