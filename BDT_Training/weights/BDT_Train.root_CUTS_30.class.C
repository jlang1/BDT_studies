// Class: ReadCUTS_30
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::CUTS_30
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/09       [336393]
Creator        : jlang
Date           : Tue Dec  8 16:22:08 2015
Host           : Linux ekpams2 2.6.32-504.16.2.el6.x86_64 #1 SMP Tue Apr 21 21:44:51 CEST 2015 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /usr/users/jlang/BDT/Test/BDT_Training
Training events: 1332
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "True" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "10" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "30" [Number of steps during node cut optimisation]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Verbose" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "2" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "1332" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
v0                            v0                            v0                            v0                                                              'F'    [-0.490635514259,1.48405468464]
v1                            v1                            v1                            v1                                                              'F'    [-7.37883806229,7.25839614868]
v2                            v2                            v2                            v2                                                              'F'    [-1.8986569643,6.2026591301]
v3                            v3                            v3                            v3                                                              'F'    [1.46819293499,2.39548110962]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new CUTS_30Node
   
#ifndef CUTS_30Node__def
#define CUTS_30Node__def
   
class CUTS_30Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   CUTS_30Node ( CUTS_30Node* left,CUTS_30Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~CUTS_30Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   CUTS_30Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   CUTS_30Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   CUTS_30Node*   fLeft;     // pointer to the left daughter node
   CUTS_30Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   CUTS_30Node::~CUTS_30Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool CUTS_30Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool CUTS_30Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadCUTS_30 : public IClassifierReader {

 public:

   // constructor
   ReadCUTS_30( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadCUTS_30" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "v0", "v1", "v2", "v3" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = -0.490635514259338;
      fVmax[0] = 1.48405468463898;
      fVmin[1] = -7.37883806228638;
      fVmax[1] = 7.25839614868164;
      fVmin[2] = -1.89865696430206;
      fVmax[2] = 6.20265913009644;
      fVmin[3] = 1.46819293498993;
      fVmax[3] = 2.39548110961914;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadCUTS_30() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<CUTS_30Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadCUTS_30::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      CUTS_30Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(CUTS_30Node*)current->GetRight();
         else current=(CUTS_30Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadCUTS_30::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(2.53304872579476);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.95171, 0, 1, 0.995984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272727,-99) , 
0, 0.799515, 1, 0, 0.674603,-99) , 
3, 1.93672, 0, 0, 0.93109,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.133333,-99) , 
0, 0.558025, 1, 0, 0.369863,-99) , 
NN(
0, 
0, 
-1, 1.78351, 0, -1, 0.00817996,-99) , 
3, 1.80591, 0, 0, 0.120056,-99) , 
3, 1.88697, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.50834);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79776, 0, 0, 0.434285,-99) , 
NN(
0, 
0, 
-1, 1.54407, 0, -1, 0.118679,-99) , 
2, 2.21181, 0, 0, 0.232345,-99) , 
3, 1.94679, 0, 0, 0.382579,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.62336);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.81438, 0, 0, 0.516108,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.977367,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.192547,-99) , 
2, 4.24405, 0, 0, 0.205302,-99) , 
0, 0.663987, 0, 0, 0.278664,-99) , 
3, 1.94679, 0, 0, 0.364867,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.930894);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.810248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482981,-99) , 
2, 1.54648, 0, 0, 0.687543,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339735,-99) , 
3, 1.95053, 0, 0, 0.406962,-99) , 
2, 2.26228, 1, 0, 0.56501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.528853,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.778553);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.92981, 0, 1, 0.659359,-99) , 
NN(
0, 
0, 
-1, 1.1796, 1, -1, 0.103956,-99) , 
0, 1.10156, 1, 0, 0.6328,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.604571,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.757554);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406104,-99) , 
1, 0.334775, 1, 0, 0.616319,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.944974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354075,-99) , 
1, 2.53671, 0, 0, 0.37184,-99) , 
0, -0.0299166, 1, 0, 0.416954,-99) , 
3, 1.94679, 0, 0, 0.445138,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.575537);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.94484, 0, 1, 0.866166,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365864,-99) , 
0, 0.789913, 1, 0, 0.564487,-99) , 
3, 1.92981, 0, 0, 0.59277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.577485,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.700444);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403778,-99) , 
3, 1.89099, 1, 0, 0.833184,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401648,-99) , 
1, -0.572181, 1, 0, 0.521294,-99) , 
0, 0.590438, 1, 0, 0.609509,-99) , 
NN(
NN(
0, 
0, 
-1, 2.74673, 0, 1, 0.678809,-99) , 
NN(
0, 
0, 
-1, 0.334103, 1, -1, 0.360707,-99) , 
3, 1.91688, 0, 0, 0.415023,-99) , 
0, 0.528559, 0, 0, 0.481612,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.355504);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.914024,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.584333, 1, 0, 0.847663,-99) , 
NN(
0, 
0, 
-1, 1.67212, 0, 1, 0.547969,-99) , 
3, 1.80833, 1, 0, 0.574066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.563719,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.296636);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.85886, 0, 1, 0.734966,-99) , 
NN(
0, 
0, 
-1, -0.16266, 0, -1, 0.448264,-99) , 
0, -0.219163, 1, 0, 0.468329,-99) , 
3, 1.94679, 0, 0, 0.479393,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.286292);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.569528, 1, 1, 0.951875,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493778,-99) , 
0, 0.528559, 0, 0, 0.542625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92509, 0, 0, 0.0523536,-99) , 
2, 0.453338, 0, 0, 0.530725,-99) , 
1, 2.53671, 0, 0, 0.540742,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.337422);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.926892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.584333, 1, 0, 0.874464,-99) , 
NN(
0, 
0, 
-1, 1.67212, 0, 1, 0.540996,-99) , 
3, 1.80833, 1, 0, 0.572335,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.564322,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.534775);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.896643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.78351, 0, 0, 0.746978,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675444,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416318,-99) , 
1, 1.82505, 0, 0, 0.446749,-99) , 
3, 1.80706, 1, 0, 0.474972,-99) , 
3, 1.94679, 0, 0, 0.483513,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.359322);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.781781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0571489,-99) , 
0, 0.90137, 1, 0, 0.751883,-99) , 
NN(
0, 
0, 
-1, 3.36087, 0, 1, 0.554651,-99) , 
2, 1.01949, 1, 0, 0.57643,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.772458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92509, 0, 0, 0.0394606,-99) , 
1, 1.55582, 0, 0, 0.139468,-99) , 
2, 0.453338, 0, 0, 0.566968,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.373983);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.996953,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.87419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.319971,-99) , 
1, 1.03288, 1, 0, 0.736921,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397852,-99) , 
2, 1.98475, 1, 0, 0.455336,-99) , 
2, 3.58933, 0, 0, 0.472937,-99) , 
0, -0.426936, 1, 0, 0.481492,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.242638);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.995577,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46645,-99) , 
2, 3.21128, 0, 0, 0.487979,-99) , 
NN(
0, 
0, 
-1, 1.89148, 0, -1, 0.026732,-99) , 
0, 1.17668, 1, 0, 0.479723,-99) , 
0, -0.426936, 1, 0, 0.486841,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.271072);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.545775,-99) , 
NN(
0, 
0, 
-1, 0.148978, 0, -1, 0.0225636,-99) , 
0, 1.22926, 1, 0, 0.539644,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675151,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92509, 0, 0, 0.0347724,-99) , 
1, 1.55582, 0, 0, 0.122761,-99) , 
2, 0.453338, 0, 0, 0.531286,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.294226);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.794071,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451587,-99) , 
3, 1.80704, 1, 0, 0.469854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.462496,-99) , 
3, 1.94679, 0, 0, 0.468283,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.22231);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.995779,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539437,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.151643,-99) , 
2, 0.469187, 0, 0, 0.533467,-99) , 
NN(
0, 
0, 
-1, 1.89148, 0, -1, 0.0365372,-99) , 
0, 1.17668, 1, 0, 0.526928,-99) , 
0, -0.426936, 1, 0, 0.532856,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.157952);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.994733,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.46988,-99) , 
3, 1.94679, 0, 0, 0.474435,-99) , 
0, -0.426936, 1, 0, 0.480364,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.142536);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.993838,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.518469,-99) , 
NN(
0, 
0, 
-1, 1.89148, 0, -1, 0.0452221,-99) , 
0, 1.17668, 1, 0, 0.513235,-99) , 
0, -0.426936, 1, 0, 0.518317,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.133002);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.9929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.474946,-99) , 
3, 1.94679, 0, 0, 0.478881,-99) , 
0, -0.426936, 1, 0, 0.48396,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0990004);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.991898,-99) , 
NN(
NN(
0, 
0, 
-1, 0.914964, 0, 1, 0.51615,-99) , 
NN(
0, 
0, 
-1, 1.89148, 0, -1, 0.0517911,-99) , 
0, 1.17668, 1, 0, 0.511629,-99) , 
0, -0.426936, 1, 0, 0.516083,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0675292);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.991063,-99) , 
NN(
0, 
0, 
-1, 1.76732, 0, -1, 0.487356,-99) , 
0, -0.426936, 1, 0, 0.491811,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.105752);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.990445,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.172355,-99) , 
2, 0.53836, 0, 0, 0.508012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.504235,-99) , 
0, -0.426936, 1, 0, 0.508398,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.125789);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.98939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.475528,-99) , 
3, 1.94679, 0, 0, 0.47903,-99) , 
0, -0.426936, 1, 0, 0.483185,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0816313);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.426948, 1, 1, 0.517172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.513718,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.155183);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.987985,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478912,-99) , 
0, 0.914964, 0, 0, 0.4939,-99) , 
NN(
0, 
0, 
-1, 1.89148, 0, -1, 0.0532108,-99) , 
0, 1.17668, 1, 0, 0.489912,-99) , 
0, -0.426936, 1, 0, 0.493583,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.165677);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487432,-99) , 
0, 0.44604, 1, 0, 0.855888,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0433833,-99) , 
2, 0.53836, 0, 0, 0.522139,-99) , 
1, 2.53155, 0, 0, 0.527053,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.523837,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.120602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.41621, 1, 1, 0.987575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451948,-99) , 
0, 0.569528, 1, 0, 0.848206,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382087,-99) , 
3, 1.91688, 1, 0, 0.483447,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.92509, 0, 0, 0.0501192,-99) , 
2, 0.453338, 0, 0, 0.47909,-99) , 
1, 2.53671, 0, 0, 0.48427,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.207792);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.41621, 1, 1, 0.986005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481958,-99) , 
0, 0.569528, 1, 0, 0.849474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.455317,-99) , 
3, 1.94679, 0, 0, 0.458771,-99) , 
1, 2.53671, 0, 0, 0.464026,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.29526);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.55997, 0, 1, 0.976915,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.920692,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327094,-99) , 
1, -1.89612, 0, 0, 0.487819,-99) , 
2, 2.55166, 0, 0, 0.639464,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.704198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.198745,-99) , 
2, 0.601669, 0, 0, 0.633026,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383713,-99) , 
3, 1.83287, 0, 0, 0.486651,-99) , 
2, 0.976004, 1, 0, 0.501821,-99) , 
1, -1.71281, 1, 0, 0.514278,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.445966);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.55997, 0, 1, 0.96923,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.782604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334233,-99) , 
1, -2.07888, 0, 0, 0.523038,-99) , 
2, 2.55166, 0, 0, 0.654081,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346535,-99) , 
1, 0.242291, 1, 0, 0.578935,-99) , 
NN(
0, 
0, 
-1, -1.4197, 0, -1, 0.428807,-99) , 
3, 1.82714, 1, 0, 0.45445,-99) , 
1, -1.71281, 1, 0, 0.471218,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.255958);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.44604, 1, 1, 0.888843,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0934793,-99) , 
2, 0.53836, 0, 0, 0.549783,-99) , 
1, 2.53155, 0, 0, 0.55469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.76732, 0, 0, 0.551699,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.128388);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.569528, 1, 1, 0.85184,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.987152,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478212,-99) , 
3, 1.94679, 0, 0, 0.481328,-99) , 
0, -0.426936, 1, 0, 0.484709,-99) , 
1, 2.53671, 0, 0, 0.4896,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.249466);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.819512, 0, 1, 0.675746,-99) , 
NN(
0, 
0, 
-1, 0.778263, 0, -1, 0.0576223,-99) , 
0, 0.90137, 1, 0, 0.642763,-99) , 
NN(
NN(
0, 
0, 
-1, -1.08423, 1, 1, 0.525153,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589758,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0759375,-99) , 
0, 0.306098, 1, 0, 0.352356,-99) , 
2, 1.48427, 0, 0, 0.506899,-99) , 
2, 0.976004, 1, 0, 0.520084,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.307268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.826274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.34174,-99) , 
2, 0.694007, 0, 0, 0.673505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00905118,-99) , 
0, 0.756014, 0, 0, 0.407852,-99) , 
0, 0.466312, 1, 0, 0.591661,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.981235,-99) , 
NN(
0, 
0, 
-1, 1.48427, 0, -1, 0.447068,-99) , 
0, -0.426936, 1, 0, 0.450315,-99) , 
2, 0.976004, 1, 0, 0.46359,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.208757);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.569528, 1, 1, 0.872058,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0666211,-99) , 
0, 1.22926, 1, 0, 0.533369,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00639877,-99) , 
0, 0.425544, 1, 0, 0.300464,-99) , 
1, 2.19746, 1, 0, 0.525666,-99) , 
1, 2.53671, 0, 0, 0.530154,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.134207);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.569528, 1, 1, 0.846904,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.472935,-99) , 
3, 1.94679, 0, 0, 0.475835,-99) , 
1, 2.53671, 0, 0, 0.480319,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0898627);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 1.79714, 1, 1, 0.51517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.510122,-99) , 
3, 1.94679, 0, 0, 0.512704,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.110311);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804108,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48571,-99) , 
3, 1.79714, 1, 0, 0.49271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.488091,-99) , 
3, 1.94679, 0, 0, 0.490672,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.40373);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.990129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.82017, 0, 0, 0.941737,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450201,-99) , 
0, 0.396605, 0, 0, 0.52086,-99) , 
2, 2.41109, 1, 0, 0.553719,-99) , 
NN(
NN(
0, 
0, 
-1, 0.203478, 0, 1, 0.578293,-99) , 
NN(
0, 
0, 
-1, 2.13673, 1, -1, 0.383688,-99) , 
0, 0.33746, 1, 0, 0.481197,-99) , 
2, 2.28267, 0, 0, 0.516801,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.214705);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.864472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438265,-99) , 
3, 1.8278, 0, 0, 0.76377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.867585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00811735,-99) , 
2, 0.761892, 1, 0, 0.274134,-99) , 
2, 1.4934, 0, 0, 0.658943,-99) , 
NN(
NN(
0, 
0, 
-1, 0.741398, 0, 1, 0.517629,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0798288,-99) , 
2, 3.20105, 1, 0, 0.404621,-99) , 
0, 0.783358, 1, 0, 0.500095,-99) , 
1, -1.71281, 1, 0, 0.512309,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.292388);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.837295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491625,-99) , 
3, 1.8278, 0, 0, 0.751313,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.840917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0100419,-99) , 
2, 0.761892, 1, 0, 0.272437,-99) , 
2, 1.4934, 0, 0, 0.651763,-99) , 
NN(
NN(
0, 
0, 
-1, 4.8806, 0, 1, 0.902248,-99) , 
NN(
0, 
0, 
-1, 0.63021, 0, -1, 0.447094,-99) , 
2, 4.63466, 0, 0, 0.450188,-99) , 
1, -1.71281, 1, 0, 0.464769,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.287367);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.985754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.82017, 0, 0, 0.940004,-99) , 
NN(
0, 
0, 
-1, -1.85015, 1, 1, 0.541285,-99) , 
2, 2.41109, 1, 0, 0.567687,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543747,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321586,-99) , 
2, 2.13836, 1, 0, 0.523684,-99) , 
NN(
0, 
0, 
-1, -0.984845, 1, -1, 0.349059,-99) , 
1, -0.768474, 0, 0, 0.494271,-99) , 
2, 2.28267, 0, 0, 0.530131,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.307109);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.09196, 1, 1, 0.998193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.932711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422541,-99) , 
1, -1.89612, 0, 0, 0.568077,-99) , 
2, 3.08079, 0, 0, 0.655409,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455867,-99) , 
1, -1.13348, 1, 0, 0.470167,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.988102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.156172,-99) , 
0, 0.0863478, 1, 0, 0.253302,-99) , 
1, -1.4197, 0, 0, 0.463755,-99) , 
1, -1.71281, 1, 0, 0.476289,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.256506);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.09196, 1, 1, 0.997545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.8278, 0, 0, 0.606601,-99) , 
2, 3.08079, 0, 0, 0.679329,-99) , 
NN(
NN(
0, 
0, 
-1, -1.13348, 1, 1, 0.541883,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.983893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.201028,-99) , 
0, 0.0863478, 1, 0, 0.288442,-99) , 
1, -1.4197, 0, 0, 0.53508,-99) , 
1, -1.71281, 1, 0, 0.544021,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.179997);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.13427, 0, 1, 0.727386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.858852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0172809,-99) , 
2, 0.761892, 1, 0, 0.328546,-99) , 
2, 1.4934, 0, 0, 0.638672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79008, 0, -1, 0.471551,-99) , 
3, 1.94679, 0, 0, 0.474018,-99) , 
1, -1.71281, 1, 0, 0.483645,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.220657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.41621, 1, 1, 0.984982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476556,-99) , 
0, 0.569528, 1, 0, 0.846643,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465692,-99) , 
0, 0.592259, 1, 0, 0.527505,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563484,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00604234,-99) , 
0, 0.425544, 1, 0, 0.315755,-99) , 
1, 2.19746, 1, 0, 0.520162,-99) , 
1, 2.53671, 0, 0, 0.523808,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.52759);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.683441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.82074, 0, 0, 0.64809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00827979,-99) , 
0, 0.924039, 1, 0, 0.40146,-99) , 
2, 2.80533, 1, 0, 0.566074,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723901,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272548,-99) , 
0, 0.431844, 1, 0, 0.577716,-99) , 
NN(
0, 
0, 
-1, 2.47036, 1, -1, 0.431177,-99) , 
2, 2.87924, 0, 0, 0.464652,-99) , 
0, 0.528559, 0, 0, 0.496351,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.444641);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.24976, 0, 1, 0.582214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644695,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0589039,-99) , 
2, 3.62961, 0, 0, 0.340418,-99) , 
2, 3.55629, 1, 0, 0.561087,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.931952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455414,-99) , 
3, 1.92305, 0, 0, 0.486945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.750658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.085236,-99) , 
3, 1.83011, 1, 0, 0.169421,-99) , 
0, 0.651294, 0, 0, 0.421884,-99) , 
0, 0.592259, 1, 0, 0.52872,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.52022);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215281,-99) , 
2, 1.52346, 0, 0, 0.635254,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.899213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.754464, 1, 0, 0.37285,-99) , 
3, 1.83712, 0, 0, 0.58582,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392077,-99) , 
0, 0.200438, 0, 0, 0.472415,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0808966,-99) , 
3, 1.87733, 1, 0, 0.20779,-99) , 
0, 0.581826, 1, 0, 0.446335,-99) , 
0, 0.655959, 0, 0, 0.472524,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.676644);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.763962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449245,-99) , 
0, 0.00849398, 1, 0, 0.681872,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224747,-99) , 
0, 0.0438459, 0, 0, 0.360586,-99) , 
1, 1.0615, 1, 0, 0.579937,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339111,-99) , 
0, 0.199372, 0, 0, 0.510532,-99) , 
NN(
0, 
0, 
-1, 0.422563, 0, -1, 0.380485,-99) , 
0, 0.308805, 1, 0, 0.411785,-99) , 
0, 0.0826616, 1, 0, 0.457843,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.328731);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.889262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.14186,-99) , 
1, 0.551693, 1, 0, 0.863788,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.8384, 0, 0, 0.614898,-99) , 
0, 0.79062, 1, 0, 0.671362,-99) , 
NN(
NN(
0, 
0, 
-1, 1.60382, 1, 1, 0.987277,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.143235,-99) , 
2, 0.699212, 0, 0, 0.510041,-99) , 
1, 2.53155, 0, 0, 0.517944,-99) , 
0, 0.655959, 0, 0, 0.548304,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.454446);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.278417, 0, 1, 0.829574,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.127964,-99) , 
2, 3.20105, 1, 0, 0.548914,-99) , 
0, 0.79062, 1, 0, 0.609161,-99) , 
NN(
NN(
0, 
0, 
-1, 1.60382, 1, 1, 0.982412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413786,-99) , 
1, -1.08114, 1, 0, 0.433716,-99) , 
1, 2.53155, 0, 0, 0.441469,-99) , 
0, 0.655959, 0, 0, 0.472939,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.320505);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.255398,-99) , 
2, 0.824343, 0, 0, 0.587714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.91491, 0, 0, 0.125024,-99) , 
0, 0.979398, 1, 0, 0.576545,-99) , 
NN(
NN(
0, 
0, 
-1, -0.388075, 0, 1, 0.986087,-99) , 
NN(
0, 
0, 
-1, -0.181086, 0, -1, 0.465557,-99) , 
0, -0.299572, 1, 0, 0.478736,-99) , 
1, 0.175863, 0, 0, 0.527013,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.510422);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456485,-99) , 
2, 1.76, 0, 0, 0.578812,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.986761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.180468,-99) , 
1, -0.888946, 1, 0, 0.312462,-99) , 
0, -0.172197, 0, 0, 0.558018,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0559428,-99) , 
0, 0.558025, 1, 0, 0.711768,-99) , 
NN(
0, 
0, 
-1, -0.0249597, 0, -1, 0.420313,-99) , 
2, 1.59677, 1, 0, 0.485746,-99) , 
1, 0.648032, 1, 0, 0.531117,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.489593);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.993453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477854,-99) , 
2, 1.69931, 1, 0, 0.825532,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224857,-99) , 
0, -0.181586, 0, 0, 0.559285,-99) , 
0, -0.299536, 1, 0, 0.57125,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.852859,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407148,-99) , 
0, -0.00788304, 0, 0, 0.631037,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.76013,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38716,-99) , 
2, 3.6143, 0, 0, 0.428513,-99) , 
0, 0.155286, 1, 0, 0.482307,-99) , 
2, 2.544, 1, 0, 0.53846,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.281115);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.759802,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334545,-99) , 
0, -0.333034, 0, 0, 0.553255,-99) , 
3, 1.86995, 0, 0, 0.707657,-99) , 
NN(
NN(
0, 
0, 
-1, 1.9299, 0, 1, 0.555636,-99) , 
NN(
0, 
0, 
-1, -0.174326, 0, -1, 0.444756,-99) , 
2, 2.544, 0, 0, 0.485297,-99) , 
0, -0.235837, 1, 0, 0.497763,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.132858);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.704845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399731,-99) , 
0, -0.333034, 0, 0, 0.554516,-99) , 
3, 1.86995, 0, 0, 0.699664,-99) , 
NN(
NN(
0, 
0, 
-1, -0.119705, 1, 1, 0.510825,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0168733,-99) , 
3, 1.89424, 0, 0, 0.176015,-99) , 
0, -0.176438, 0, 0, 0.504124,-99) , 
0, -0.235837, 1, 0, 0.514328,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.223682);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431992,-99) , 
0, -0.333034, 0, 0, 0.555153,-99) , 
3, 1.86995, 0, 0, 0.695435,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468992,-99) , 
0, -0.119705, 1, 0, 0.477627,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.993973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0174176,-99) , 
2, 2.51358, 0, 0, 0.177668,-99) , 
0, -0.176438, 0, 0, 0.471996,-99) , 
0, -0.235837, 1, 0, 0.483293,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.364951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.86975, 1, 1, 0.706487,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0675685,-99) , 
0, 0.979398, 1, 0, 0.526274,-99) , 
1, -0.509013, 1, 0, 0.5496,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.899486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378904,-99) , 
2, 1.50281, 0, 0, 0.692335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.274723,-99) , 
1, -1.62926, 1, 0, 0.369132,-99) , 
0, 0.0181959, 1, 0, 0.444924,-99) , 
1, -0.768474, 0, 0, 0.531563,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.175082);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 1.79166, 0, -1, 0.458922,-99) , 
3, 1.94679, 0, 0, 0.461965,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.121664);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663841,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472811,-99) , 
0, -0.333034, 0, 0, 0.557441,-99) , 
3, 1.86995, 0, 0, 0.682961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494618,-99) , 
0, 1.05639, 0, 0, 0.502878,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0159561,-99) , 
3, 1.89424, 0, 0, 0.151623,-99) , 
0, -0.176438, 0, 0, 0.496451,-99) , 
0, -0.235837, 1, 0, 0.505172,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.247352);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361873,-99) , 
2, 3.5563, 1, 0, 0.534396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.528805,-99) , 
3, 1.94679, 0, 0, 0.531334,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.164645);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471884,-99) , 
3, 1.93083, 0, 0, 0.481578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.477094,-99) , 
3, 1.94679, 0, 0, 0.479593,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.580315);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.19266, 0, 1, 0.987593,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244532,-99) , 
1, 1.0615, 1, 0, 0.517558,-99) , 
0, 0.0454665, 0, 0, 0.575909,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487402,-99) , 
0, 0.578784, 1, 0, 0.561818,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.995838,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350742,-99) , 
2, 2.89569, 0, 0, 0.418219,-99) , 
0, 0.444411, 0, 0, 0.497671,-99) , 
0, 0.0826616, 1, 0, 0.515654,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.38685);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.977821,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.136608,-99) , 
2, 0.62839, 0, 0, 0.905924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0140983,-99) , 
2, 1.06957, 0, 0, 0.618164,-99) , 
2, 0.714671, 1, 0, 0.644388,-99) , 
NN(
NN(
0, 
0, 
-1, 3.24976, 0, 1, 0.531804,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0777702,-99) , 
2, 3.62961, 0, 0, 0.334373,-99) , 
2, 3.55629, 1, 0, 0.515641,-99) , 
0, 0.528559, 0, 0, 0.557465,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.354792);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.967683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.188942,-99) , 
2, 0.62839, 0, 0, 0.897885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244882,-99) , 
2, 1.42358, 0, 0, 0.52926,-99) , 
2, 0.714671, 1, 0, 0.558801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.960455,-99) , 
NN(
0, 
0, 
-1, 1.40965, 1, -1, 0.42193,-99) , 
1, 2.53155, 0, 0, 0.428134,-99) , 
0, 0.528559, 0, 0, 0.469274,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.347176);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.833547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.100673,-99) , 
2, 0.594312, 0, 0, 0.74459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.788436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206333,-99) , 
2, 0.833047, 0, 0, 0.481822,-99) , 
1, 0.18368, 1, 0, 0.635327,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362618,-99) , 
2, 1.44657, 0, 0, 0.515337,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544673,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.305517,-99) , 
0, 0.909737, 0, 0, 0.421274,-99) , 
0, 0.592259, 1, 0, 0.491767,-99) , 
2, 0.976004, 1, 0, 0.504845,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.397898);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.909712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0313282,-99) , 
2, 0.222515, 0, 0, 0.83843,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.812225,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385942,-99) , 
0, 0.692834, 0, 0, 0.524373,-99) , 
0, -0.0308973, 1, 0, 0.594164,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403932,-99) , 
1, 0.519463, 0, 0, 0.442662,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0443143,-99) , 
0, 0.404, 1, 0, 0.241637,-99) , 
1, 2.10184, 1, 0, 0.434931,-99) , 
2, 1.23734, 1, 0, 0.453857,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.328567);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.75553, 0, 1, 0.716601,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.991115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461647,-99) , 
0, -0.0453199, 1, 0, 0.494474,-99) , 
2, 1.71248, 1, 0, 0.567014,-99) , 
NN(
0, 
0, 
-1, 1.41038, 1, -1, 0.436139,-99) , 
1, -0.296305, 1, 0, 0.480645,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.418029);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.386898, 0, 1, 0.59162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242699,-99) , 
3, 1.90108, 0, 0, 0.344579,-99) , 
0, -0.172197, 0, 0, 0.576858,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.731313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.162123,-99) , 
0, 0.558025, 1, 0, 0.693889,-99) , 
NN(
0, 
0, 
-1, -0.0249597, 0, -1, 0.43077,-99) , 
2, 1.59677, 1, 0, 0.482064,-99) , 
1, 0.648032, 1, 0, 0.542796,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.286448);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431204,-99) , 
2, 2.98542, 1, 0, 0.561139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79723, 0, 0, 0.554251,-99) , 
NN(
NN(
0, 
0, 
-1, -0.357911, 1, 1, 0.974991,-99) , 
NN(
0, 
0, 
-1, -0.181086, 0, -1, 0.457209,-99) , 
0, -0.299572, 1, 0, 0.467057,-99) , 
1, 0.175863, 0, 0, 0.507475,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.24311);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.935412,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485833,-99) , 
0, 0.000370141, 0, 0, 0.81798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.287903,-99) , 
0, 0.895729, 1, 0, 0.70508,-99) , 
NN(
NN(
0, 
0, 
-1, 0.44604, 1, 1, 0.88526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471739,-99) , 
1, -0.0370097, 1, 0, 0.512577,-99) , 
1, 2.53671, 0, 0, 0.516594,-99) , 
2, 3.58933, 0, 0, 0.525905,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.400878);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.924021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4331,-99) , 
3, 1.86975, 1, 0, 0.668433,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341101,-99) , 
1, -0.254459, 0, 0, 0.536644,-99) , 
1, -0.509013, 1, 0, 0.552236,-99) , 
NN(
NN(
0, 
0, 
-1, -1.24886, 1, 1, 0.970022,-99) , 
NN(
0, 
0, 
-1, 1.81104, 0, -1, 0.409767,-99) , 
2, 3.45866, 0, 0, 0.436051,-99) , 
1, -0.768474, 0, 0, 0.532224,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.473789);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.484684, 0, 1, 0.620382,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.641204, 1, 0, 0.440069,-99) , 
3, 1.83903, 0, 0, 0.576618,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724303,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448623,-99) , 
2, 2.05109, 1, 0, 0.49358,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.267346,-99) , 
1, 1.65404, 0, 0, 0.351686,-99) , 
2, 1.79325, 0, 0, 0.452704,-99) , 
1, -0.296305, 1, 0, 0.494479,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.478408);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.254985, 1, 1, 0.579444,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0669247,-99) , 
1, 1.1857, 0, 0, 0.16653,-99) , 
3, 1.8135, 0, 0, 0.550117,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.929155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446543,-99) , 
2, 1.63882, 0, 0, 0.614242,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.235419,-99) , 
3, 1.87927, 0, 0, 0.405739,-99) , 
3, 1.82421, 1, 0, 0.446937,-99) , 
2, 2.02133, 0, 0, 0.508329,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.433228);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.846787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.81295, 0, 0, 0.798404,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189726,-99) , 
2, 0.73945, 0, 0, 0.42279,-99) , 
3, 1.85388, 1, 0, 0.613444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.921541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.405465,-99) , 
2, 4.17188, 1, 0, 0.636584,-99) , 
NN(
0, 
0, 
-1, -2.1953, 0, -1, 0.414942,-99) , 
2, 3.67495, 0, 0, 0.424432,-99) , 
2, 0.976004, 1, 0, 0.440889,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.301987);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79008, 0, 0, 0.548646,-99) , 
3, 1.94679, 0, 0, 0.551901,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.996406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49312,-99) , 
2, 1.8492, 0, 0, 0.739014,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373641,-99) , 
3, 1.92916, 0, 0, 0.399958,-99) , 
0, -0.045408, 1, 0, 0.432041,-99) , 
1, -0.768474, 0, 0, 0.530775,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.118994);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377347,-99) , 
3, 1.91598, 1, 0, 0.481133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.477243,-99) , 
3, 1.94679, 0, 0, 0.480403,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.234456);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438485,-99) , 
0, 0.159211, 1, 0, 0.461456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.457936,-99) , 
3, 1.94679, 0, 0, 0.461029,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.187215);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.010125, 0, 1, 0.967475,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321262,-99) , 
1, 0.901765, 1, 0, 0.846189,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.97887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481782,-99) , 
2, 3.38131, 0, 0, 0.496056,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00825721,-99) , 
2, 3.61363, 0, 0, 0.3008,-99) , 
2, 3.55959, 1, 0, 0.484722,-99) , 
2, 4.37333, 0, 0, 0.488524,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.161723);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 1.2314, 1, 0, 0.529844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.526467,-99) , 
3, 1.94679, 0, 0, 0.529109,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.127344);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.252508, 1, 1, 0.640489,-99) , 
NN(
0, 
0, 
-1, 0.0331656, 0, -1, 0.477489,-99) , 
3, 1.93029, 0, 0, 0.486956,-99) , 
3, 1.94679, 0, 0, 0.489605,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.174646);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433435,-99) , 
1, 1.48547, 1, 0, 0.517983,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.79166, 0, 0, 0.515112,-99) , 
3, 1.94679, 0, 0, 0.517467,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.259769);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467201,-99) , 
3, 1.85435, 1, 0, 0.498452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.231891,-99) , 
2, 2.08102, 1, 0, 0.387172,-99) , 
3, 1.82246, 0, 0, 0.485463,-99) , 
3, 1.94679, 0, 0, 0.487761,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.536639);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678949,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.15579,-99) , 
1, 2.0631, 1, 0, 0.636017,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.241339,-99) , 
0, 0.506061, 0, 0, 0.4964,-99) , 
1, 0.278651, 0, 0, 0.555746,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.173966,-99) , 
3, 1.81359, 0, 0, 0.541858,-99) , 
NN(
0, 
0, 
-1, 1.70567, 1, -1, 0.382929,-99) , 
2, 1.9691, 0, 0, 0.475916,-99) , 
0, 0.40116, 0, 0, 0.516256,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.2939);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.997529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295342,-99) , 
0, 0.754234, 0, 0, 0.937221,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.980876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469523,-99) , 
2, 4.18596, 0, 0, 0.474478,-99) , 
0, 0.741398, 0, 0, 0.486757,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.980339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0992577,-99) , 
0, 0.923516, 0, 0, 0.852704,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.197033,-99) , 
1, 0.249317, 0, 0, 0.330538,-99) , 
1, -1.60089, 1, 0, 0.371174,-99) , 
0, 0.783358, 1, 0, 0.467126,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.356996);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.996687,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359927,-99) , 
0, 0.754234, 0, 0, 0.937043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482438,-99) , 
2, 2.55881, 1, 0, 0.546488,-99) , 
0, 0.741398, 0, 0, 0.555545,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.973798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.128801,-99) , 
0, 0.923516, 0, 0, 0.848573,-99) , 
NN(
0, 
0, 
-1, 3.20105, 1, -1, 0.332959,-99) , 
1, -1.60089, 1, 0, 0.369771,-99) , 
0, 0.783358, 1, 0, 0.525211,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.109928);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.9109, 0, 1, 0.878605,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.986777,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.22503,-99) , 
0, -0.360216, 0, 0, 0.511751,-99) , 
0, -0.426936, 1, 0, 0.514417,-99) , 
1, 2.53671, 0, 0, 0.518458,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.174978);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.9109, 0, 1, 0.866384,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.985263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458057,-99) , 
2, 2.544, 0, 0, 0.485176,-99) , 
0, -0.426936, 1, 0, 0.487839,-99) , 
1, 2.53671, 0, 0, 0.491878,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.109327);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.9109, 0, 1, 0.8448,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.982494,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.609598,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48606,-99) , 
1, 1.87825, 0, 0, 0.496231,-99) , 
0, -0.426936, 1, 0, 0.498619,-99) , 
1, 2.53671, 0, 0, 0.502102,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.192341);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0.252508, 1, 1, 0.679659,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529726,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420658,-99) , 
0, 0.790151, 1, 0, 0.512356,-99) , 
3, 1.93029, 0, 0, 0.522011,-99) , 
3, 1.94679, 0, 0, 0.524235,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.260276);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.20291, 0, 1, 0.602722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.10949,-99) , 
2, 2.70314, 0, 0, 0.432488,-99) , 
2, 2.46084, 1, 0, 0.540025,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361274,-99) , 
0, 0.0429494, 0, 0, 0.474781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
3, 1.91491, 0, 0, 0.0612156,-99) , 
0, 0.979398, 1, 0, 0.466579,-99) , 
1, -0.296305, 1, 0, 0.490531,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.327392);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.363798, 0, 1, 0.89458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272974,-99) , 
3, 1.86995, 0, 0, 0.420416,-99) , 
1, 0.484005, 0, 0, 0.628966,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412215,-99) , 
0, 0.307965, 1, 0, 0.445463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.00552338,-99) , 
3, 1.89424, 0, 0, 0.182991,-99) , 
0, -0.176438, 0, 0, 0.439254,-99) , 
0, -0.235837, 1, 0, 0.447936,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.501021);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.792135, 0, 1, 0.647236,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353257,-99) , 
1, 0.25691, 0, 0, 0.493897,-99) , 
1, -0.572181, 1, 0, 0.529508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631894,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426654,-99) , 
1, -0.240412, 0, 0, 0.480739,-99) , 
NN(
0, 
0, 
-1, 0.288537, 1, -1, 0.337165,-99) , 
1, 0.251063, 1, 0, 0.411035,-99) , 
0, 0.40116, 0, 0, 0.469903,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.309518);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.363798, 0, 1, 0.909869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.992753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417885,-99) , 
1, -0.842835, 1, 0, 0.566178,-99) , 
1, 0.484005, 0, 0, 0.733528,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27395,-99) , 
1, -2.12986, 0, 0, 0.541637,-99) , 
NN(
0, 
0, 
-1, 1.41038, 1, -1, 0.448245,-99) , 
1, -0.296305, 1, 0, 0.479493,-99) , 
0, -0.235837, 1, 0, 0.491265,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.335405);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.998505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386447,-99) , 
1, -0.407363, 0, 0, 0.877188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.996076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362488,-99) , 
1, -0.228684, 1, 0, 0.547363,-99) , 
0, -0.350287, 0, 0, 0.736737,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462482,-99) , 
1, -0.476443, 0, 0, 0.542451,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42444,-99) , 
2, 0.975557, 1, 0, 0.450627,-99) , 
3, 1.85706, 0, 0, 0.511141,-99) , 
0, -0.235837, 1, 0, 0.520875,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.21342);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 1,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.82095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488225,-99) , 
0, -0.333034, 0, 0, 0.657457,-99) , 
3, 1.86995, 0, 0, 0.751562,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48973,-99) , 
3, 1.88439, 0, 0, 0.540108,-99) , 
NN(
0, 
0, 
-1, 0.599585, 1, -1, 0.46575,-99) , 
1, 0.648032, 1, 0, 0.510884,-99) , 
0, -0.235837, 1, 0, 0.520337,-99)    );
   return;
};
 
// Clean up
inline void ReadCUTS_30::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadCUTS_30::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
